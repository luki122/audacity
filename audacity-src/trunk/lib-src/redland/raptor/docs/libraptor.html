<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Fri Jun 20 14:26:02 2008 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Raptor RDF Parser Toolkit - Raptor API</title>
</head>
<body bgcolor="#ffffff" text="#000085">
<h1>Raptor RDF Parser Toolkit - Raptor API</h1>
<hr />
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>libraptor &#8722; Raptor RDF parser and serializer library</p>
</td>
</tr>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>
<b>#include &lt;raptor.h&gt;

raptor_init();
raptor_parser *</b><i>p</i><b>=raptor_new_parser("rdfxml");
raptor_set_statement_handler(</b><i>p</i><b>,</b><i>NULL</i><b>,</b><i>print_triples</i><b>);
raptor_uri *</b><i>file_uri</i><b>=raptor_new_uri("http://example.org/");
raptor_parse_file(</b><i>p</i><b>,</b><i>file_uri</i><b>,</b><i>base_uri</i><b>);
raptor_parse_uri(</b><i>p</i><b>,</b><i>uri</i><b>,</b><i>NULL</i><b>);
raptor_free_parser(</b><i>p</i><b>);
raptor_free_uri(</b><i>file_uri</i><b>);
raptor_finish();

cc file.c -lraptor
</b>
</pre></td>
</tr>
</table>
<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <i>Raptor</i> library provides a high-level interface to a set of parsers and serializers that generate Resource Description Framework (RDF) triples by parsing syntaxes or serialize the triples into syntaxes.</p>
<!-- INDENTATION -->
<p>The supported parsing syntaxes are RDF/XML, N-Triples, Turtle, RSS tag soup including Atom 0.3 and the serializing syntaxes are RDF/XML, N-Triples and RSS 1.0. The RDF/XML parser can use either <i>expat</i> or <i>libxml</i> XML parsers for providing the SAX event stream. The library functions are arranged in an object-oriented style with constructors, destructors and method calls. The statements and error messages are delivered via callback functions.</p>
<!-- INDENTATION -->
<p>Raptor contains a URI-reference parsing and resolving (not retrieval) class (raptor_uri) sufficient for dealing with URI-references inside RDF. This functionality is modular and can be transparently replaced with another existing and compatible URI implementation.</p>
<!-- INDENTATION -->
<p>It also provides a URI-retrieval class (raptor_www) for wrapping existing library such as libcurl, libxml2 or BSD libfetch that provides full or partial retrieval of data from URIs and an I/O stream abstraction (raptor_iostream) for supportin serializing to a variety of outputs.</p>
<!-- INDENTATION -->
<p>Raptor uses Unicode strings for RDF literals and URIs and preserves them throughout the library. It uses the UTF-8 encoding of Unicode at the API for passing in or returning Unicode strings. It is intended that the preservation of Unicode for URIs will support Internationalized Resource Identifiers (IRIs) which are still under development and standardisation.</p>
</td>
</tr>
</table>
<a name="LIBRARY_INITIALISATION_AND_CLEANUP"></a>
<h2>LIBRARY INITIALISATION AND CLEANUP</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_init()</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_finish()</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Initialise and cleanup the library. These must be called before any raptor class such as raptor_parser, raptor_uri is created or used.</p>
</td>
</tr>
</table>
<a name="PARSER_CLASS"></a>
<h2>PARSER CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This class provides the functionality of turning syntaxes into RDF triples - RDF parsing.</p>
</td>
</tr>
</table>
<a name="PARSER_CONSTRUCTORS"></a>
<h2>PARSER CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_parser* raptor_new_parser(name)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor parser object for the parser with name <i>name</i> currently either "rdfxml", "turtle" or "rss-tag-soup" for the RSS Tag Soup parser.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_parser* raptor_new_parser_for_content(raptor_uri *</b><i>uri</i><b>, const char *</b><i>mime_type</i><b>, const unsigned char *</b><i>buffer</i><b>, size_t</b> <i>len</i><b>, const unsigned char *</b><i>identifier</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor parser object for a syntax identified by URI <i>uri</i>, MIME type <i>mime_type</i>, some initial content <i>buffer</i> of size <i>len</i> or content with identifier <i>identifier</i>. See the raptor_guess_parser_name description for further details.</p>
</td>
</tr>
</table>
<a name="PARSER_DESTRUCTOR"></a>
<h2>PARSER DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_parser(raptor_parser *</b><i>parser</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a Raptor parser object.</p>
</td>
</tr>
</table>
<a name="PARSER_MESSAGE_CALLBACK_METHODS"></a>
<h2>PARSER MESSAGE CALLBACK METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Several methods can be registered for the parser that return a variable-argument message in the style of printf(3). These also return a <i>raptor_locator</i> that can contain URI, file, line, column and byte counts of where the message is about. This structure can be used with the raptor_format_locator, raptor_print_locator functions below or the structures fields directly, which are defined in raptor.h</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_fatal_error_handler(raptor_parser*</b> <i>parser, void *user_data, raptor_message_handler handler)</i></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the parser fatal error handler callback.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_error_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the parser non-fatal error handler callback.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_warning_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the parser warning message handler callback.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_set_namespace_handler(raptor_parser*</b> <i>parser</i><b>, void*</b> <i>user_data</i><b>, raptor_namespace_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the namespace declaration handler callback.</p>
</td>
</tr>
</table>
<a name="PARSER_STATEMENT_CALLBACK_METHOD"></a>
<h2>PARSER STATEMENT CALLBACK METHOD</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The parser allows the registration of a callback function to return the statements to the application.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_statement_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_statement_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the statement callback function for the parser. The <i>raptor_statement</i> structure is defined in raptor.h and includes fields for the subject, predicate, object of the statements along with their types and for literals, language and datatype.</p>
</td>
</tr>
</table>
<a name="PARSER_PARSING_METHODS"></a>
<h2>PARSER PARSING METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>These methods perform the entire parsing in one method. Statements warnings, errors and fatal errors are delivered via the registered statement, error etc. handler functions.</p>
<!-- INDENTATION -->
<p>In both of these methods, the base URI is required for the RDF/XML parser (name "rdfxml") and Turtle parser (name "turtle"). The N-Triples parser (name "ntriples") or RSS Tag Soup parser (name "rss-tag-soup") do not use this.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_file(raptor_parser*</b> <i>parser</i><b>, raptor_uri *</b><i>uri</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the given filename (a URI like file:filename) according to the optional base URI <i>base_uri</i>. If <i>uri</i> is NULL, read from standard input and <i>base_uri</i> is then required.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_file_stream(raptor_parser*</b> <i>parser</i><b>, FILE*</b> <i>stream</i><b>, const char*</b> <i>filename</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the given C FILE* stream according to the base URI <i>base_uri</i> (required). <i>filename</i> is optional and if given, is used for error messages via the raptor_locator structure.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_uri(raptor_parser*</b> <i>parser</i><b>, raptor_uri*</b> <i>uri</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the URI according to the base URI <i>base_uri</i>, or NULL if not needed. If no base URI is given, the <i>uri</i> is used. This method depends on the raptor_www subsystem (see <b>WWW Class</b> section below) and an existing underlying URI retrieval implementation such as libcurl, libxml or BSD libfetch to retrieve the content.</p>
</td>
</tr>
</table>
<a name="PARSER_CHUNKED_PARSING_METHODS"></a>
<h2>PARSER CHUNKED PARSING METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>These methods perform the parsing in parts by working on multiple chunks of memory passed by the application. Statements warnings, errors and fatal errors are delivered via the registered statement, error etc. handler functions.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_start_parse(raptor_parser*</b> <i>parser</i><b>, const char *</b><i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start a parse of chunked content with the base URI <i>uri</i> or NULL if not needed. The base URI is required for the RDF/XML parser (name "rdfxml") and Turtle parser (name "turtle"). The N-Triples parser (name "ntriples") or RSS Tag Soup parser (name "rss-tag-soup") do not use this.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parse_chunk(raptor_parser*</b> <i>parser</i><b>, const unsigned char *buffer, size_t</b> <i>len</i><b>, int</b> <i>is_end</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the memory at <i>buffer</i> of size <i>len</i> returning statements via the statement handler callback. If <i>is_end</i> is non-zero, it indicates the end of the parsing stream. This method can only be called after <b>raptor_start_parse()</b>.</p>
</td>
</tr>
</table>
<a name="PARSER_UTILITY_METHODS"></a>
<h2>PARSER UTILITY METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char* raptor_get_mime_type(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the MIME type for the parser.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_parser_strict(raptor_parser *</b><i>parser</i><b>, int</b> <i>is_strict</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the parser to strict (<i>is_strict</i> not zero) or lax (default) mode. The detail of the strictness can be controlled by raptor_set_feature.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_set_feature(raptor_parser *</b><i>parser</i><b>, raptor_feature</b> <i>feature</i><b>, int</b> <i>value</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set a parser feature <i>feature</i> to a particular <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined parser features are: <i>Feature Values</i> <b>RAPTOR_FEATURE_ALLOW_BAGID</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_ASSUME_IS_RDF</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_CHECK_RDF_ID</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_HTML_LINK</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_HTML_TAG_SOUP</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_MICROFORMATS</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_NON_NFC_FATAL</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_NORMALIZE_LANGUAGE</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_NO_NET</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_RELATIVE_URIS</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_SCANNING</b> Boolean (non 0 true)
<b>RAPTOR_FEATURE_WARN_OTHER_PARSETYPES</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_WWW_TIMEOUT</b> Integer <b>RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL</b> String <b>RAPTOR_FEATURE_WWW_HTTP_USER_AGENT</b> String</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If the <i>allow_bagid</i> feature is true (default true) then the RDF/XML parser will support the rdf:bagID attribute that was removed from the RDF/XML language when it was revised. This support may be removed in future.</p>
<!-- INDENTATION -->
<p>If the <i>allow_non_ns_attributes</i> feature is true (default true), then the RDF/XML parser will allow non-XML namespaced attributes to be accepted as well as rdf: namespaced ones. For example, &#8217;about&#8217; and &#8217;ID&#8217; will be interpreted as if they were rdf:about and rdf:ID respectively.</p>
<!-- INDENTATION -->
<p>If the <i>allow_other_parsetypes</i> feature is true (default true) then the RDF/XML parser will allow unknown parsetypes to be present and will pass them on to the user. Unimplemented at present.</p>
<!-- INDENTATION -->
<p>If the <i>allow_rdf_type_rdf_list</i> feature is true (default false) then the RDF/XML parser will generate the idList rdf:type rdf:List triple in the handling of rdf:parseType="Collection". This triple was removed during the revising of RDF/XML after collections were initially added.</p>
<!-- INDENTATION -->
<p>If the <i>assume_is_rdf</i> feature is true (default false), then the RDF/XML parser will assume the content is RDF/XML, not require that rdf:RDF root element, and immediately interpret the content as RDF/XML.</p>
<!-- INDENTATION -->
<p>If the <i>check_rdf_id</i> feature is true (default true) then rdf:ID values will be checked for duplicates and cause an error if found.</p>
<!-- INDENTATION -->
<p>if the <i>html_link</i> feature is true (default true), look for head &amp;lt;link&amp;gt; to type rdf/xml for GRDDL parser</p>
<!-- INDENTATION -->
<p>If the <i>html_tag_soup</i> feature is true (default true), use a lax HTML parser if an XML parser fails when read HTML for GRDDL parser.</p>
<!-- INDENTATION -->
<p>If the <i>microformats</i> feature is true (default true), look for microformats for GRDDL parser.</p>
<!-- INDENTATION -->
<p>If the <i>non_nfc_fatal</i> feature is true (default false) then illegal Unicode Normal Form C in literals will give a fatal error, otherwise it gives a warning.</p>
<!-- INDENTATION -->
<p>If the <i>normalize_language</i> feature is true (default true) then XML language values such as from xml:lang will be normalized to lowercase.</p>
<!-- INDENTATION -->
<p>If the <i>no_net</i> feature is true (default false) then network requests are denied.</p>
<!-- INDENTATION -->
<p>If the <i>scanning</i> feature is true (default false), then the RDF/XML parser will look for embedded rdf:RDF elements inside the XML content, and not require that the XML start with an rdf:RDF root element.</p>
<!-- INDENTATION -->
<p>If the <i>www_timeout</i> feature is set to an integer larger than 0, it sets the timeout in seconds for internal WWW URI requests for the GRDDL parser.</p>
<!-- INDENTATION -->
<p>If the <i>www_http_cache_control</i> feature is set to a string value (default none), it is sent as the value of the HTTP Cache-Control: header in requests.</p>
<!-- INDENTATION -->
<p>If the <i>www_http_user_agent</i> feature is set to a string value, it is sent as the value of the HTTP User-Agent: header in requests.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_parser_set_feature_string(raptor_parser *</b><i>parser</i><b>, raptor_feature</b> <i>feature</i><b>, const unsigned char *</b><i>value</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set a parser feature <i>feature</i> to a particular string <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined parser features are given in <b>raptor_set_feature</b> and at present only take integer values. If an integer value feature is set with this function, <i>value</i> is interpreted as an integer and then that value is used.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_get_feature(raptor_parser*</b> <i>parser</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get parser feature integer values. The allowed <i>feature</i> values and types are given under <b>raptor_features_enumerate</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_parser_get_feature_string(raptor_parser *</b><i>parser</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get parser feature string values. The allowed <i>feature</i> values and types are given under <b>raptor_features_enumerate</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned int raptor_get_feature_count(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the count of features defined. Prefered to the compile time-only symbol <b>RAPTOR_FEATURE_LAST</b> which returns the maximum value, not the count. Added raptor_get_need_base_uri</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_feature_value_type(const raptor_feature feature)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get a raptor feature value tyype - integer or string.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_locator* raptor_get_locator(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current raptor_locator object for the parser. This is a public structure defined in raptor.h that can be used directly, or formatted via raptor_print_locator.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_get_name(raptor_parser *</b><i>parser</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the string short name for the parser.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_get_label(raptor_parser *</b><i>parser</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a string label for the parser.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_default_generate_id_parameters(raptor_parser*</b> <i>rdf_parser</i><b>, char *</b><i>prefix</i><b>, int</b> <i>base</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Control the default method for generation of IDs for blank nodes and bags. The method uses a short string <i>prefix</i> and an integer <i>base</i> to generate the identifier which is not guaranteed to be a strict concatenation. If <i>prefix</i> is NULL, the default is used. If base is less than 1, it is initialised to 1.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_generate_id_handler(raptor_parser*</b> <i>parser</i><b>, void *</b><i>user_data</i><b>, raptor_generate_id_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Allow full customisation of the generated IDs by setting a callback <i>handler</i> and associated <i>user_data</i> that is called whenever a blank node or bag identifier is required. The memory returned is deallocated inside raptor. Some systems require this to be allocated inside the same library, in which case the <b>raptor_alloc_memory</b> function may be useful.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_parser_set_uri_filter(raptor_parser*</b> <i>parser</i><b>, raptor_uri_filter_func</b> <i>filter</i><b>, void*</b> <i>user_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the URI filter function <i>filter</i> for URIs retrieved during parsing by the the raptor_parser.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_get_need_base_uri(raptor_parser*</b> <i>rdf_parser</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get a boolean whether this parser needs a base URI to start parsing.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_parser_generate_id(raptor_parser*</b> <i>rdf_parser</i><b>, raptor_genid_type</b> <i>type</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Generate an ID for a parser of type <i>type</i>, either <b>RAPTOR_GENID_TYPE_BNODEID</b> or <b>RAPTOR_GENID_TYPE_BAGID</b>. This uses any configuration set by <b>raptor_set_generate_id_handler</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_set_graph_handler(raptor_parser*</b> <i>parser</i><b>, void*</b> <i>user_data</i><b>, raptor_graph_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the graph handler callback.</p>
</td>
</tr>
</table>
<a name="PARSER_UTILITY_FUNCTIONS"></a>
<h2>PARSER UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_parsers_enumerate(const unsigned int</b> <i>counter</i><b>, const char **</b><i>name</i><b>, const char **</b><i>label</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the parser name/label for a parser with a given integer counter, returning non-zero if no such parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_syntaxes_enumerate(const unsigned int</b> <i>counter</i><b>, const char **name, const char **</b><i>label</i><b>, const char **</b><i>mime_type</i><b>, const unsigned char **</b><i>uri-string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the name, label, mime type or URI string (all optional) for a parser syntax with a given integer counter, returning non-zero if no such syntax parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_features_enumerate(const raptor_feature</b> <i>feature</i><b>, const char **</b><i>name</i><b>, raptor_uri **</b><i>uri</i><b>, const char **</b><i>label</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the name, URI, string label (all optional) for a parser <i>feature</i>, returning non-zero if no such feature exists.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Raptor features have URIs that are constructed from the URI <i>http://feature.librdf.org/raptor-</i> and the <i>name</i> so for example feature <i>scanForRDF</i> has URI <i>http://feature.librdf.org/raptor-scanForRDF</i></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_syntax_name_check(const char *</b><i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Check <i>name</i> is a known syntax name.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char* raptor_guess_parser_name(raptor_uri *</b><i>uri</i><b>, const char *</b><i>mime_type</i><b>, const unsigned char *</b><i>buffer</i><b>, size_t</b> <i>len</i><b>, const unsigned char *</b><i>identifier</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Guess a parser name for a syntax identified by URI <i>uri</i>, MIME type <i>mime_type</i>, some initial content <i>buffer</i> of size <i>len</i> or with content identifier <i>identifier</i>. All of these parameters are optional and only used if not NULL. The parser is chosen by scoring the hints that are given.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_feature raptor_feature_from_uri(raptor_uri *</b><i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Turn a URI <i>uri</i> into a raptor feature identifier, or &lt;0 if the feature is unknown. The URIs are described below raptor_set_feature.</p>
</td>
</tr>
</table>
<a name="STATEMENT_UTILITY_FUNCTIONS"></a>
<h2>STATEMENT UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_statement_compare(const raptor_statement *</b><i>s1</i><b>, const raptor_statement *</b><i>s2</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Compare two statements and return an ordering between them.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_statement(const raptor_statement* const</b> <i>statement</i><b>, FILE *</b><i>stream</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Print a raptor statement object in a simple format for debugging only. The format of this output is not guaranteed to remain the same between releases.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_statement_as_ntriples(const raptor_statement*</b> <i>statement</i><b>, FILE *</b><i>stream</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Print a raptor statement object in N-Triples format, using all the escapes as defined in <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">http://www.w3.org/TR/rdf-testcases/#ntriples</a></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_statement_part_as_counted_string(const void *</b><i>term</i><b>, raptor_identifier_type</b> <i>type</i><b>, raptor_uri*</b> <i>literal_datatype</i><b>, const unsigned char *</b><i>literal_language</i><b>, size_t*</b> <i>len_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char* raptor_statement_part_as_string(const void *</b><i>term</i><b>, raptor_identifier_type</b> <i>type</i><b>, raptor_uri*</b> <i>literal_datatype</i><b>, const unsigned char *</b><i>literal_language</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Turns part of raptor statement into N-Triples format, using all the escapes as defined in <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">http://www.w3.org/TR/rdf-testcases/#ntriples</a> The part (subject, predicate, object) of the raptor_statement is passed in as <i>term</i>, the part type (subject_type, predicate_type, object_type) is passed in as <i>type</i>. When the part is a literal, the <i>literal_datatype</i> and <i>literal_language</i> fields are set, otherwise NULL (usually object_datatype, object_literal_language).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>If <b>raptor_statement_part_as_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
</td>
</tr>
</table>
<a name="LOCATOR_UTILITY_FUNCTIONS"></a>
<h2>LOCATOR UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_format_locator(char *</b><i>buffer</i><b>, size_t</b> <i>length</i><b>, raptor_locator*</b> <i>locator</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This method takes a <i>raptor_locator</i> object as passed to an error, warning or other handler callback and formats it into the <i>buffer</i> of size <i>length</i> bytes. If <i>buffer</i> is NULL or <i>length</i> is insufficient for the size of the formatted locator, returns the number of additional bytes required in the buffer to write the locator.</p>
<!-- INDENTATION -->
<p>In particular, if this form is used: length=raptor_format_locator(NULL, 0, locator) it will return in <i>length</i> the size of a buffer that can be allocated for <i>locator</i> and a second call will perform the formatting: raptor_format_locator(buffer, length, locator)</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_locator(FILE *</b><i>stream</i><b>, raptor_locator*</b> <i>locator</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This method takes a <i>raptor_locator</i> object as passed to an error, warning or other handler callback, formats and prints it to the given stdio <i>stream</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_locator_line(raptor_locator *locator)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns the line number in a locator structure or &lt;0 if not available.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_locator_column(raptor_locator *locator)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns the column number in a locator structure or &lt;0 if not available.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_locator_byte(raptor_locator *locator)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns the byte offset in a locator structure or &lt;0 if not available.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * raptor_locator_file(raptor_locator *locator)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns the filename in a locator structure or NULL if not available. Note the returned pointer is to a shared string that must be copied if needed.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * raptor_locator_uri(raptor_locator *locator)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns the URI string in a locator structure or NULL if not available. Note this does not return a raptor_uri* pointer and the returned pointer is to a shared string that must be copied if needed.</p>
</td>
</tr>
</table>
<a name="N-TRIPLES_UTILITY_FUNCTIONS"></a>
<h2>N-TRIPLES UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_print_ntriples_string(FILE*</b> <i>stream</i><b>, const char*</b> <i>string</i><b>, const char</b> <i>delim</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that prints the given string according to N-Triples escaping rules, expecting to be terminated by delimiter <i>delim</i> which is usually either &#8217;, " or &lt;. If a null delimiter \0 is given, no extra escaping is performed.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_string_ntriples(raptor_iostream *</b><i>iostr</i><b>, const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>, const char</b> <i>delim</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write an N-Triples encoded version of the given string to iostream <i>iostr</i>. If <i>delim</i> is given, that is the ending delimeter of the encoded string and it will be escaped in the output as appropriate. Useful delim values are &#8217;, " and &gt;. If a null delimiter \0 is given, no extra escaping is performed.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int raptor_iostream_write_string_python(raptor_iostream *<i>iostr</i>, const unsigned char *<i>string</i>, size_t <i>len</i>, const char <i>delim</i>, int <i>flags</i>)</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write <i>string</i> encoded to an iostream according to the delimeter <i>delim</i> and encoding flags. The <i>flag</i> value selects formatting according to the appropriate Python-related languages such as N-Triples (0), Turtle (1), Turtle long quoted string (2), JSON (3).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_iostream_write_statement_ntriples(raptor_iostream* iostr, const raptor_statement *statement)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write an N-Triples encoded version of the raptor_statement <i>statement</i> to iostream <i>iostr</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_iostream_write_string_turtle(raptor_iostream*</b> <i>iostr</i><b>, const unsigned char*</b> <i>string</i><b>, size_t</b> <i>len</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>DEPRECATED in 1.4.17 - use raptor_iostream_write_string_python instead. Write an UTF-8 <i>string</i> of length <i>len</i> using the Turtle "longString" triple quoting format to the iostream <i>iostr</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char* raptor_ntriples_term_as_string (raptor_ntriples_term_type</b> <i>term</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Deprecated, for internal use.</p>
</td>
</tr>
</table>
<a name="XML_UTILITY_FUNCTIONS"></a>
<h2>XML UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_any_escape_string(const unsigned char*</b> <i>string</i><b>, size_t</b> <i>len</i><b>, unsigned char*</b> <i>buffer</i><b>, size_t</b> <i>length</i><b>, char</b> <i>quote</i><b>, int</b> <i>xml_version</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void*</b> <i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_escape_string(const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>, unsigned char *</b><i>buffer</i><b>, size_t</b> <i>length</i><b>, char</b> <i>quote</i><b>, raptor_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Apply the XML escaping rules to the string given in (string, len) into the <i>buffer</i> of size <i>length</i>. If <i>quote</i> is given, the escaped content is for an XML attribute and the appropriate quote character XML element content (CDATA). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given. If buffer is NULL, returns the size of the buffer required to escape. Otherwise the return value is the number of bytes used or &lt;0 on failure.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>When an <i>xml_version</i> argument is present and has a value 10 (XML 1.0) or 11 (XML 1.1) then that version is used. The default with no argument is to generate XML 1.0.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_xml_any_escaped_string(raptor_iostream*</b> <i>iostr</i><b>, const unsigned char*</b> <i>string</i><b>, size_t</b> <i>len</i><b>, char</b> <i>quote</i><b>, int</b> <i>xml_version</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void*</b> <i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_xml_escaped_string(raptor_iostream*</b> <i>iostr</i><b>, const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>, char</b> <i>quote</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write an XML-escaped version of the string given in (string, len) to iostream <i>iostr</i>. If <i>quote</i> is given, the escaped content is for an XML attribute and the appropriate quote character is used, otherwise it is XML element content (CDATA). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>When an <i>xml_version</i> argument is present and has a value 10 (XML 1.0) or 11 (XML 1.1) then that version is used. The default with no argument is to generate XML 1.0.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_name_check(const unsigned char *</b><i>string</i><b>, size_t</b> <i>length</i><b>, int xml_version)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Check that the given <i>string</i> of <i>length</i> bytes is a legal XML name according to XML 1.0 or XML 1.1. <i>xml_version</i> is set to 10 or 11 respectively. Returns non-zero if the name is legal.</p>
</td>
</tr>
</table>
<a name="MEMORY_UTILITY_FUNCTIONS"></a>
<h2>MEMORY UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_memory(void *</b><i>ptr</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Free memory allocated inside raptor. Some systems require memory allocated in a library to be deallocated inside that library. This function can be used in that situation to free memory allocated by raptor, such as the result of the <i>_to_</i> methods that return allocated memory such as <b>raptor_uri_to_filename</b>, <b>raptor_uri_to_string</b>, <b>raptor_uri_to_relative_counted_uri_string</b>, <b>raptor_uri_to_relative_uri_string</b> or <b>raptor_new_namespace_parts_from_string</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_alloc_memory(size_t</b> <i>size</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Allocate memory inside the raptor library. Some systems require memory allocated in a library to be deallocated inside that library. This function can be used in that situation to allocate memory for raptor to free later, such as inside the handler function declared with <b>raptor_set_generate_id_handler</b> which returns new memory.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_calloc_memory(size_t</b> <i>nmemb</i><b>, size_t</b> <i>size</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Allocate zeroed array of items inside raptor. Some systems require memory allocated in a library to be deallocated inside that library. This function can be used in that situation to clear an array of allocated memory for raptor to use, for freeing later, such as inside the handler function declared with <b>raptor_set_generate_id_handler</b> which returns new memory.</p>
</td>
</tr>
</table>
<a name="UNICODE_UTILITY_FUNCTIONS"></a>
<h2>UNICODE UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_unicode_char_to_utf8(raptor_unichar</b> <i>c</i><b>, unsigned char *</b><i>output</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Turn a Unicode character into UTF8 bytes in <i>output</i> of size <i>c</i> bytes which must be of sufficient size. Returns the number of bytes encoded or &lt;0 on failure.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_utf8_to_unicode_char(raptor_unichar *</b><i>output</i><b>, const unsigned char *</b><i>input</i><b>, int</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Decode a sequence UTF8 bytes in <i>input</i> of size <i>length</i> into a Unicode character in <i>output</i> returning the number of bytes used or &lt;0 on failure.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_utf8_check(const unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>gth)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Check that a given <i>string</i> is legal UTF-8 encoding and includes only legal Unicode characters U+0 to U+0x10ffff inclusive. Returns non-0 if the string is good.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_unicode_is_xml11_namestartchar(raptor_unichar</b> <i>c</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_unicode_is_xml10_namestartchar(raptor_unichar</b> <i>c</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_unicode_is_xml11_namechar(raptor_unichar</b> <i>c</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_unicode_is_xml10_namechar(raptor-unichar</b> <i>c</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Check that given Unicode characters are allowed as XML 1.0 or XML 1.0 names - either as the starting character (<b>*_namestartchar</b>) or continuing character (<b>*_namechar</b>). Returns non-0 if the character is allowed.</p>
</td>
</tr>
</table>
<a name="ERROR_UTILITY_FUNCTIONS"></a>
<h2>ERROR UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_error_handlers_init(raptor_error_handlers*</b> <i>error_handlers</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Initialise an error_handlers structure after the log level handlers and user data pointers have been set.</p>
</td>
</tr>
</table>
<a name="MISCELLANEOUS_UTILITY_FUNCTIONS"></a>
<h2>MISCELLANEOUS UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char* raptor_vsnprintf(const char *message, va_list arguments)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Compatibility wrapper around vsnprintf.</p>
</td>
</tr>
</table>
<a name="STATIC_VARIABLES"></a>
<h2>STATIC VARIABLES</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>There are several read-only static variables in the raptor library:</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_short_copyright_string</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Short copyright string, suitable for one line.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_copyright_string</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Full copyright over several lines including URLs.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_version_string</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The version as a string</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_major</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The major version number as an integer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_minor</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The minor version number as an integer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_release</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The release version number as an integer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned int raptor_version_decimal</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The version number as a single decimal.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_license_string</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The license string over several lines including URLs.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char * const raptor_home_url_string</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>The home page URL as a string.</p>
</td>
</tr>
</table>
<a name="SERIALIZER_CLASS"></a>
<h2>SERIALIZER CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This class provides the functionality of turning RDF triples into syntaxes - RDF serializing.</p>
</td>
</tr>
</table>
<a name="SERIALIZER_CONSTRUCTOR"></a>
<h2>SERIALIZER CONSTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_serializer* raptor_new_serializer(const char *</b><i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor serializer object for the serializer with name <i>name</i> currently either "rdfxml" or "ntriples". or "rss-1.0" for the RSS 1.0 serializer.</p>
</td>
</tr>
</table>
<a name="SERIALIZER_DESTRUCTOR"></a>
<h2>SERIALIZER DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_serializer(raptor_serializer*</b> <i>rdf_serializer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a Raptor serializer object.</p>
</td>
</tr>
</table>
<a name="SERIALIZER_SERIALIZING_METHODS"></a>
<h2>SERIALIZER SERIALIZING METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_start(raptor_serializer*</b> <i>rdf_serializer</i><b>, raptor_uri *</b><i>uri</i><b>, raptor_iostream *</b><i>iostream</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start to serialize content using the given <i>iostream</i> to write to with optional base URI <i>uri</i>. The <i>iostream</i> becomes owned by the serializer object and is destroyed at the end of serializing when raptor_serialize_end() is called. Note that some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_start_to_iostream(raptor_serializer*</b> <i>rdf_serializer</i><b>, raptor_uri*</b> <i>uri</i><b>, raptor_iostream*</b> <i>iostream</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start to serialize content using the given <i>iostream</i> to write to with optional base URI <i>uri</i>. The <i>iostream</i> does NOT become owned by the serializer object and the caller may continue to write to it after serializing is finished. Note that some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_start_to_filename(raptor_serializer*</b> <i>rdf_serializer</i><b>, const char *</b><i>filename</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start to serialize content to the file <i>filename</i> which is opened for writing. The base URI is calculated from the file name.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_start_to_string(raptor_serializer*</b> <i>rdf_serializer</i><b>, raptor_uri *</b><i>uri</i><b>, void **</b><i>string_p</i><b>, size_t *</b><i>length_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start to serialize content to a string. <i>string_p</i> must point to a void* pointer that will be used at the end of serializing to store the newly allocated string. <i>length_p</i> if not NULL, it will be used to store the length of the new string. The serializing is done with optional base URI <i>uri</i> however some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_start_to_file_handle(raptor_serializer*</b> <i>rdf_serializer</i><b>, raptor_uri *</b><i>uri</i><b>, FILE *</b><i>handle</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start to serialize content to the already open C Standard I/O FILE* <i>handle</i> with the base URI <i>uri</i>, which is optional and may be NULL. Note that some syntaxes may refuse to serialize without a base URI, such as RDF/XML.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_statement(raptor_serializer*</b> <i>rdf_serializer</i><b>, const raptor_statement *</b><i>statement</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Serialize a single <i>statement</i> using the serializer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serialize_end(raptor_serializer*</b> <i>rdf_serializer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>End the serializing. This may close and delete resources used in serializing. No more calls to raptor_serialize_statement or raptor_serialize_end may be done at this point.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_serializer_get_iostream(raptor_serializer *</b><i>serializer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a pointer to the raptor_iostream* used by the serializer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serializer_set_namespace(raptor_serializer*</b> <i>serializer</i><b>, raptor_uri *</b><i>uri</i><b>, const char *</b><i>prefix</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set a suggested namespace URI/prefix mapping for use in serializing.</p>
</td>
</tr>
</table>
<a name="SERIALIZER_UTILITY_METHODS"></a>
<h2>SERIALIZER UTILITY METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_serializer_set_error_handler(raptor_serializer*</b> <i>serializer</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the serializer non-fatal error handler callback.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_serializer_set_warning_handler(raptor_serializer*</b> <i>serializer</i><b>, void *</b><i>user_data</i><b>, raptor_message_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the serializer warning message handler callback.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_locator* raptor_serializer_get_locator(raptor_serializer*</b> <i>rdf_serializer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current raptor_locator object for the serializer. This is a public structure defined in raptor.h that can be used directly, or formatted via raptor_print_locator.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serializer_set_feature(raptor_serializer *</b><i>serializer</i><b>, raptor_feature</b> <i>feature</i><b>, int</b> <i>value</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set a serializer feature <i>feature</i> to a particular <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined serializer features are: <i>Feature Values</i> <b>RAPTOR_FEATURE_RELATIVE_URIS</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_WRITE_BASE_URI</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_START_URI</b> URI String <b>RAPTOR_FEATURE_BNODE_BORDER</b> String <b>RAPTOR_FEATURE_BNODE_FILL</b> String <b>RAPTOR_FEATURE_JSON_CALLBACK</b> String <b>RAPTOR_FEATURE_JSON_EXTRA_DATA</b> String <b>RAPTOR_FEATURE_LITERAL_BORDER</b> String <b>RAPTOR_FEATURE_LITERAL_FILL</b> String <b>RAPTOR_FEATURE_RESOURCE_BORDER</b> String <b>RAPTOR_FEATURE_RESOURCE_FILL</b> String <b>RAPTOR_FEATURE_RSS_TRIPLES</b> String <b>RAPTOR_FEATURE_ATOM_ENTRY_URI</b> String</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If the <i>relative_uris</i> feature is true (default false) then when serialising, preference is given to generating relative URIs where possible.</p>
<!-- INDENTATION -->
<p>If the <i>write_base_uri</i> feature is true (default true) then the atom, rdfxml, rdfxml-abbrev and turtle serializers will write an @base or xml:base directive in the output.</p>
<!-- INDENTATION -->
<p>If the <i>start_uri</i> feature is set to a URI it is used by the serializer to start serializing from.</p>
<!-- INDENTATION -->
<p>If the <i>bnode_border</i> feature is set, the DOT serializer uses it as the bnode border colour.</p>
<!-- INDENTATION -->
<p>If the <i>bnode_fill</i> feature is set, the DOT serializer uses it as the bnode fill colour.</p>
<!-- INDENTATION -->
<p>If the <i>json_callback</i> feature is set, the JSON serializers use it as the name of the callback to wrap the outer JSON object.</p>
<!-- INDENTATION -->
<p>If the <i>json_extra_data</i> feature is set, the JSON serializers use it as extra data inside the outer JSON object.</p>
<!-- INDENTATION -->
<p>If the <i>literal_border</i> feature is set, the DOT serializer uses it as the literal border colour.</p>
<!-- INDENTATION -->
<p>If the <i>literal_fill</i> feature is set, the DOT serializer uses it as the literal fill colour.</p>
<!-- INDENTATION -->
<p>If the <i>resource_border</i> feature is set, the DOT serializer uses it as the resource border colour.</p>
<!-- INDENTATION -->
<p>If the <i>resource_fill</i> feature is set, the DOT serializer uses it as the resource fill colour.</p>
<!-- INDENTATION -->
<p>If the <i>rss_triples</i> feature is set to the string "rdf-xml" for the rss-1.0 serializer or "atom-triples" for the atom serializer, it writes extra rdf triples into the serialized output.</p>
<!-- INDENTATION -->
<p>If the <i>atom_entry_uri</i> feature is set to a URI string, it is used to trigger generation of an atom entry document for the atom serializer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serializer_get_feature(raptor_serializer*</b> <i>serializer</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get serializer features, the allowed <i>feature</i> values are available</p>
</td>
</tr>
</table>
<a name="SERIALIZER_UTILITY_FUNCTIONS"></a>
<h2>SERIALIZER UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serializers_enumerate(const unsigned</b> <i>int counter</i><b>, const char **</b><i>name</i><b>, const char **</b><i>label</i><b>, const char **</b><i>mime_type</i><b>, const unsigned char **</b><i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the serializer name/label for a serializer with a given integer counter, returning non-zero if no such parser at that offset exists. The counter should start from 0 and be incremented by 1 until the function returns non-zero.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_serializer_syntax_name_check(const char *</b><i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Check <i>name</i> is a known serializer syntax name.</p>
</td>
</tr>
</table>
<a name="URI_CLASS"></a>
<h2>URI CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Raptor has a raptor_uri class must be used for manipulating and passing URI references. The default internal implementation uses char* strings for URIs, manipulating them and constructing them. This URI implementation can be replaced by any other that provides the equivalent functionality, using the <b>raptor_uri_set_handler</b> function.</p>
</td>
</tr>
</table>
<a name="URI_CONSTRUCTORS"></a>
<h2>URI CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>There a several constructors for raptor_uri to build them from char* strings and existing raptor_uri objects.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string URI-reference <i>uri_string</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_from_uri_local_name(raptor_uri*</b> <i>uri</i><b>, const unsigned char*</b> <i>local_name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string URI-reference <i>local_name</i> relative to an existing URI-reference. This performs concatenation of the <i>local_name</i> to the <i>uri</i> and not relative URI resolution, which is done by the raptor_new_uri_relative_to_base constructor.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_relative_to_base(raptor_uri*</b> <i>base_uri, const unsigned char* uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string URI-reference <i>uri_string</i> using relative URI resolution to the <i>base_uri</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_from_id(raptor_uri*</b> <i>base_uri</i><b>, const unsigned char*</b> <i>id</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI from a string RDF ID <i>id</i> concatenated to the <i>base_uri</i> base URI.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_for_rdf_concept(const char*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI for the RDF namespace concept <i>name</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_new_uri_for_xmlbase(raptor_uri*</b> <i>old_uri</i><b>))</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor URI suitable for use with xml:base (throw away fragment)</p>
</td>
</tr>
</table>
<a name="URI_DESTRUCTOR"></a>
<h2>URI DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_uri(raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor URI object.</p>
</td>
</tr>
</table>
<a name="URI_METHODS"></a>
<h2>URI METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_uri_equals(raptor_uri*</b> <i>uri1</i><b>, raptor_uri*</b> <i>uri2</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-zero if the given URIs are equal.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_uri_copy(raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a copy of the given raptor URI <i>uri</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_as_counted_string(raptor_uri *uri, size_t* len_p)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_as_string(raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a shared pointer to a string representation of the given raptor URI <i>uri</i>. This string is shared and must not be freed (otherwise see the <b>raptor_uri_to_*</b> methods below). If <b>raptor_uri_as_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_to_counted_string(raptor_uri *</b><i>uri</i><b>, size_t *</b><i>len_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_to_string(raptor_uri *</b><i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a to a newly alloced string representation of the given raptor URI <i>uri</i>. This string must be freed by the caller using <b>raptor_free_memory</b>. If <b>raptor_uri_to_counted_string</b> is used, the length of the returned string is stored in *<i>len_p</i> if not NULL.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_to_relative_counted_uri_string(raptor_uri *</b><i>base_uri</i><b>, raptor_uri *</b><i>reference_uri</i><b>, size_t *</b><i>length_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_uri_to_relative_uri_string(raptor_uri *</b><i>base_uri</i><b>, raptor_uri *</b><i>reference_uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return a new relative URI string of a URI <i>reference_uri against a base URI base_uri. The returned string must be freed with</i> <b>raptor_free_memory</b><i>. If</i> <b>raptor_uri_to_relative_counted_string</b> <i>is used, the length of the returned string is stored in *len_p if not NULL.</i></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_print(const raptor_uri*</b> <i>uri</i><b>, FILE *</b><i>stream</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Print URI <i>uri</i> to the file handle <i>stream</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_uri(raptor_iostream*</b> <i>iostr</i><b>, raptor_uri*</b> <i>uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write the raptor_uri <i>uri</i> to the iostream <i>ostr</i>.</p>
</td>
</tr>
</table>
<a name="URI_UTILITY_FUNCTIONS"></a>
<h2>URI UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_resolve_uri_reference (const unsigned char*</b> <i>base_uri</i><b>, const unsigned char*</b> <i>reference_uri</i><b>, char unsigned*</b> <i>buffer</i><b>, size_t</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that resolves the relative URI <i>reference_uri</i> against the base URI <i>base_uri</i> according to the URI resolution rules in RFC2396. The resulting URI is stored in <i>buffer</i> which is of <i>length</i> bytes. If this is too small, no work will be done.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char *raptor_uri_filename_to_uri_string(const unsigned char*</b> <i>filename</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>This is a standalone function that turns a local filename (Windows or Unix style as appropriate for platform) into a URI string (file). The returned string must be freed by the caller. Some systems require memory allocated in a library to be deallocated inside that library in which case <b>raptor_free_memory</b> may be used.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char *raptor_uri_uri_string_to_filename(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>char *raptor_uri_uri_string_to_filename(const unsigned char*</b> <i>uri_string</i><b>, unsigned char **</b><i>fragment_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>These are standalone functions that turn a URI string that represents a local filename (file:) into a filename, with optional URI fragment. If <i>fragment_p</i> is not NULL it points to the location to store a newly allocated string containing the fragment. The returned strings must be freed by the caller. Some systems require memory allocated in a library to be deallocated inside that library in which case <b>raptor_free_memory</b> may be used.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_uri_is_file_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>DEPRECATED in 1.4.9. Returns non-zero if the given URI string represents a filename. Use <b>raptor_uri_uri_string_is_file_uri</b> in preference.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_uri_uri_string_is_file_uri(const unsigned char*</b> <i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Returns non-zero if the given URI string represents a filename.</p>
</td>
</tr>
</table>
<a name="URI_CLASS_IMPLEMENTATION"></a>
<h2>URI CLASS IMPLEMENTATION</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_set_handler(const raptor_uri_handler *</b><i>handler</i><b>, void *</b><i>context</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Change the URI class implementation to the functions provided by the <i>handler</i> URI implementation. The <i>context</i> user data is passed in to the handler URI implementation calls.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_uri_get_handler(raptor_uri_handler **</b><i>handler</i><b>, void **</b><i>context</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current raptor URI class implementation <i>handler</i> and <i>context</i></p>
</td>
</tr>
</table>
<a name="WWW_CLASS"></a>
<h2>WWW CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This is a small wrapper class around existing WWW libraries in order to provide HTTP GET or better URI retrieval for Raptor. It is not intended to be a general purpose WWW retrieval interface.</p>
</td>
</tr>
</table>
<a name="WWW_CLASS_INITIALISATION_AND_CLEANUP"></a>
<h2>WWW CLASS INITIALISATION AND CLEANUP</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_init(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_finish(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Initialise or terminate the raptor_www infrastructure. raptor_www_init and raptor_finish are called by raptor_init and raptor_finish respecitively, otherwise must be called once each.</p>
</td>
</tr>
</table>
<!-- TABS -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="5%">
<p>NOTE</p>
</td>
<td width="4%"></td>
<td width="77%">
<p>Several of the WWW library implementations require once-only initialisation and termination functions to be called, however raptor cannot determine whether this is already done before the library is initialised in <b>raptor_www_init</b> or terminated in <b>raptor_www_finish</b>, so always performs it. This can be changed by <b>raptor_www_no_www_library_init_finish</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_no_www_library_init_finish(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>If this is called before <b>raptor_www_init</b>, it will not call the underlying WWW library global initialise or terminate functions. The application code must perform both operations.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>For example with curl, after this function is called, neither <b>curl_global_init</b> nor <b>curl_global_cleanup</b> will be called during <b>raptor_www_init</b> or <b>raptor_www_finish</b> respectively.</p>
</td>
</tr>
</table>
<a name="WWW_CONSTRUCTORS"></a>
<h2>WWW CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_www *raptor_www_new(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_www *raptor_www_new_with_connection(void*</b> <i>connection</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor WWW object capable of URI retrieval. If <i>connection</i> is given, it must match the connection object of the underlying WWW implementation. At present, this is only for libcurl, and allows you to re-use an existing curl handle, or use one which has been set up with some desired qualities.</p>
</td>
</tr>
</table>
<a name="WWW_DESTRUCTOR"></a>
<h2>WWW DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_free(raptor_www *</b><i>www</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor WWW object.</p>
</td>
</tr>
</table>
<a name="WWW_METHODS"></a>
<h2>WWW METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_user_agent(raptor_www *</b><i>www</i><b>, const char *</b><i>user_agent</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the HTTP User-Agent header value.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_www_set_http_cache_control(raptor_www*</b> <i>www</i><b>, const char*</b> <i>cache_control</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the HTTP Cache-Control header value.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_proxy(raptor_www *</b><i>www</i><b>, const char *</b><i>proxy</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the HTTP proxy - usually a string of the form http://server:port</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_www_set_write_bytes_handler(raptor_www *</b><i>www</i><b>, raptor_www_write_bytes_handler</b> <i>handler</i><b>, void *</b><i>user_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the handler to receive bytes written by the raptor_www implementation.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_content_type_handler(raptor_www *</b><i>www</i><b>, raptor_www_content_type_handler</b> <i>handler</i><b>, void *</b><i>user_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the handler to receive the HTTP Content-Type value, when/if discovered during retrieval by the raptor_www implementation.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_http_accept(raptor_www *</b><i>www</i><b>, const char *</b><i>value</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the WWW HTTP Accept: header to <i>value</i>. If <i>value</i> is NULL, an empty header is sent.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_error_handler(raptor_www *www, raptor_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the error handler routine for the raptor_www class. This takes the same arguments as the raptor_parser error, warning handler methods.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_uri_filter(raptor_www*</b> <i>www</i><b>, raptor_uri_filter_func</b> <i>filter</i><b>, void*</b> <i>user_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the URI filter function <i>filter</i> for URIs retrieved by the raptor_www object.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_www_get_connection(raptor_www *</b><i>www</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the underlying WWW library connection object. For example, for libcurl this is the curl_handle.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_set_connection_timeout(raptor_www*</b> <i>www</i><b>, int</b> <i>timeout</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the WWW connection <i>timeout</i> in seconds.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_www_get_final_uri(raptor_www*</b> <i>www</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the final URI from a WWW retrieval, which may include redirections.</p>
</td>
</tr>
</table>
<a name="WWW_ACTION_METHODS"></a>
<h2>WWW ACTION METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_www_fetch(raptor_www *www, raptor_uri *uri)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Retrieve the given URL, returning non zero on failure.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_www_fetch_to_string(raptor_www *www, raptor_uri *uri, void **string_p, size_t *length_p, void *(*malloc_handler)(size_t size))</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Retrieve the given URL to a string. <i>string_p</i> must point to a void* pointer that will be used to store the newly allocated string. <i>length_p</i> if not NULL, it will be used to store the length of the new string.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_www_abort(raptor_www *www, const char *reason)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Abort an ongoing raptor WWW operation. Typically used within one of the raptor WWW handlers.</p>
</td>
</tr>
</table>
<a name="QNAME_CLASS"></a>
<h2>QNAME CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This is a class for handling XML QNames consisting of the pair of (a URI from a namespace, a local name) along with an optional value -- useful for XML attributes. This is used with the raptor_namespace_stack and raptor_namespace classes to handle a stack of raptor_namespace that build on raptor_qname.</p>
</td>
</tr>
</table>
<a name="QNAME_CONSTRUCTORS"></a>
<h2>QNAME CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>There are two constructors for raptor_qname to build qnames with optional values on a stack of names.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_new_qname(raptor_namespace_stack *</b><i>nstack</i><b>, const unsigned char *</b><i>name</i><b>, const unsigned char *</b><i>value</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor QName <i>name</i> (a possibly :-separated name) with name to be resolved against the given <i>nstack</i> namespace stack. An optional <i>value</i> can be given, and if there is an error, the <i>error_handler</i> <b>and</b> <i>error_data</i> <b>will be used to invoke the callback.</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_new_qname_from_namespace_local_name (raptor_namespace *</b><i>ns</i><b>, const unsigned char *</b><i>local_name</i><b>, const unsigned char *</b><i>value</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor QName using the namespace name of the raptor_namespace <i>ns</i> and the local name <i>local_name</i>, along with optional value <i>value</i>. Errors are reported using the error handling and data of the namespace.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_qname_copy(raptor_qname *</b><i>qname</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor QName from an existing one, returning NULL on failure.</p>
</td>
</tr>
</table>
<a name="QNAME_DESTRUCTOR"></a>
<h2>QNAME DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_qname(raptor_qname*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor qname object.</p>
</td>
</tr>
</table>
<a name="QNAME_METHODS"></a>
<h2>QNAME METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_qname_equal(raptor_qname*</b> <i>name1</i><b>, raptor_qname *</b><i>name2</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-zero if the given QNames are equal.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_qname(raptor_iostream*</b> <i>iostr</i><b>, raptor_qname *</b><i>qname</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write the raptor_qname <i>qname</i> to the iostream <i>ostr</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_qname_get_local_name(raptor_qname*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the local name of the QName.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_qname_get_value(raptor_qname*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the value of the QName for an XML attribute QName.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_qname_get_counted_value(raptor_qname*</b> <i>name</i><b>, size_t*</b> <i>length_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the value fo the QName along with the length (if <i>length_p</i> is not NULL) for an XML attribute QName.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char* raptor_qname_to_counted_name(raptor_qname*</b> <i>qname</i><b>, size_t*</b> <i>length_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the formatted QName as a newly allocated counted string (if <i>length_p</i> is not NULL).</p>
</td>
</tr>
</table>
<a name="QNAME_UTILITY_FUNCTIONS"></a>
<h2>QNAME UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_qname_string_to_uri(raptor_namespace_stack *</b><i>nstack</i><b>, const unsigned char *</b><i>name</i><b>, size_t</b> <i>name_len</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the URI corresponding to the QName according to the RDF method; concatenating the namespace&#8217;s name (URI) with the local name. Takes the same arguments as <b>raptor_new_qname</b> but does not create a raptor_qname object.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_qname_get_namespace(raptor_qname*</b> <i>name</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the raptor_namespace used by the QName. Will never be NULL even for the default namespace in which case the URI of the returned namespace object will be NULL.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_CLASS"></a>
<h2>NAMESPACE CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>An XML namespace class - each entry is on a stack and consists of a name (URI) and prefix. The prefix or the name but not both may be empty. If the prefix is empty, it defines the default prefix. If the name is empty, it undefines the given prefix.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_CONSTRUCTORS"></a>
<h2>NAMESPACE CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_new_namespace(raptor_namespace_stack *</b><i>nstack</i><b>, const unsigned char *</b><i>prefix</i><b>, const unsigned char *</b><i>ns_uri_string</i><b>, int</b> <i>depth</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_new_namespace_from_uri(raptor_namespace_stack *</b><i>nstack</i><b>, const unsigned char *</b><i>prefix</i><b>, raptor_uri*</b> <i>ns_uri</i><b>, int</b> <i>depth</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor_namespace object on the given namespace stack <i>nstack</i> with prefix <i>prefix</i> and namespace name either from URI string <i>ns_uri_string</i> or from copying URI <i>ns_uri</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If <i>prefix</i> is NULL, it defines the URI for the default namespace prefix. If the namespace name (<i>ns_uri_string</i> or <i>ns_uri</i>) is NULL, it undefines the given <i>prefix</i> in the current scope. Both prefix and URI may be NULL to undefine the default namespace. <i>depth</i> signifies the position of the namespace on the stack; 0 is the bottom of the stack and generally the first depth for user namespace declarations.</p>
<!-- INDENTATION -->
<p>Namespaces declared on the same depth (such as on the same XML element, typically) can be handily freed with <i>raptor_namespaces_end_for_depth</i> method on the namespace stack class.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_DESTRUCTOR"></a>
<h2>NAMESPACE DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_namespace(raptor_namespace *ns)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a raptor namespace object.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_METHODS"></a>
<h2>NAMESPACE METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_namespace_get_uri(const raptor_namespace *ns)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the namespace name (URI) of the namespace.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_namespace_get_prefix(const raptor_namespace *ns)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the prefix of the namespace.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_namespace_get_counted_prefix(const raptor_namespace*</b> <i>ns</i><b>, size_t*</b> <i>length_p</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the prefix of the namespace as a string with optional count stored in the variable address <i>length_p</i> if it is not NULL.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char *raptor_namespaces_format(const raptor_namespace *ns, size_t *length_p)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Format the namespace as a string and return it as a new string, returning the length of the resulting string in <i>length_p</i> if it is not NULL. The string format is suitable for emitting in XML to declare the namespace.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_namespace(raptor_iostream*</b> <i>iostr</i><b>, raptor_namespace *</b><i>ns</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a formatted namespace declaration like xmlns... to an iostream <i>iostr</i>.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_UTILITY_FUNCTIONS"></a>
<h2>NAMESPACE UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespace_copy(raptor_namespace_stack *nstack, raptor_namespace *ns, int new_depth)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Copy the namespace from the current stack to the new one, <i>nstack</i> at depth <i>new_depth</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_new_namespace_parts_from_string(unsigned char *</b><i>string</i><b>, unsigned char **</b><i>prefix</i><b>, unsigned char **</b><i>uri_string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse <i>string</i> with an XML-style namespace declaration like xmlns="", xmlns="uri", xmlns:prefix="" or xmlns:prefix="uri" into the strings pointed to by <i>prefix</i> string and a <i>uri_string</i>. Empty prefixes or namespace names return NULL pointers. Returned strings must be freed by the caller using <b>raptor_free_memory</b>.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_STACK_CLASS"></a>
<h2>NAMESPACE STACK CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A stack of raptor_namespace objects where the namespaces on top of the stack have wider scope and override earlier (lower) namespace declarations. Intended to match the XML namespace declaring semantics using xmlns attributes.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_STACK_CONSTRUCTORS"></a>
<h2>NAMESPACE STACK CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace_stack* raptor_new_namespaces(raptor_uri_handler *uri_handler, void *uri_context, raptor_simple_message_handler error_handler, void *error_data, int defaults)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespaces_init(raptor_namespace_stack *nstack, raptor_uri_handler *handler, void *context, raptor_simple_message_handler error_handler, void *error_data, int defaults)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create or initialise a new raptor_namespace_stack object with the given URI and error handlers. <b>raptor_namespaces_new</b> allocates new memory for the namespace stack and <b>raptor_namespaces_init</b> initialises an existing declared <i>nstack</i>, which could be statically allocated. Note that <b>raptor_uri_get_handler</b> can be useful to return the current raptor URI handler/context. The <i>defaults</i> argument describes which default namespaces are declared in the empty stack. At present, 0 is none, 1 for just the XML namespace and 2 is for a typical set of namespaces used for RDF, RDFS, Dublin Core, OWL, ... that may vary over time.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>In versions 1.4.16 or newer this returns an integer result, non-0 on failure.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_STACK_DESTRUCTORS"></a>
<h2>NAMESPACE STACK DESTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_namespaces(raptor_namespace_stack *nstack)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a namespace stack object, freeing the <i>nstack</i> (goes with <b>raptor_new_namespaces</b>).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_clear(raptor_namespace_stack *nstack)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Clear a statically allocated namespace stack; does not free the <i>nstack</i>. (goes with <b>raptor_namespaces_init</b>).</p>
</td>
</tr>
</table>
<a name="NAMESPACE_STACK_METHODS"></a>
<h2>NAMESPACE STACK METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_start_namespace(raptor_namespace_stack *nstack, raptor_namespace *nspace)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start the given <i>nspace</i> on the stack, at the depth already defined.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespaces_start_namespace_full(raptor_namespace_stack *nstack, const unsigned char *prefix, const unsigned char *nspace, int depth)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor_namespace and start it on the stack. See <b>raptor_new_namespace</b> for the meaning of the argumens.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_namespaces_end_for_depth(raptor_namespace_stack *nstack, int depth)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>End (and free) all namespaces on the stack at the given <i>depth</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_namespaces_get_default_namespace (raptor_namespace_stack *nstack)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the current default raptor_namespace of the namespace stack or NULL if there is none.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace* raptor_namespaces_find_namespace_by_uri(raptor_namespace_stack *</b><i>nstack</i><b>, raptor_uri *</b><i>ns_uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Find the first namespace on the stack with the given uri <i>ns_uri</i> or NULL if there is none.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespace *raptor_namespaces_find_namespace_by_uri(raptor_namespace_stack *nstack, const unsigned char *prefix, int prefix_length)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Find the first namespace on the stack with the given namespace <i>prefix</i> or NULL if there is none.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_namespaces_namespace_in_scope(raptor_namespace_stack *nstack, const raptor_namespace *nspace)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-zero if the raptor_namespace <i>nspace</i> is declared on the stack; i.e. in scope if this is a stack of XML namespaces.</p>
</td>
</tr>
</table>
<a name="NAMESPACE_STACK_UTILITY_FUNCTIONS"></a>
<h2>NAMESPACE STACK UTILITY FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_namespaces_qname_from_uri(raptor_namespace_stack*</b> <i>nstack</i><b>, raptor_uri*</b> <i>uri</i><b>, int</b> <i>xml_version</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a raptor QName from the URI <i>uri</i> if the URI is squal one of the namespace URIs on the namespace stack <i>nstack</i> URIs concatenated to a legal XML name for the given XML version. URIs are created and errors are reported using the namespace stack fields. Fails if it cannot be legally described with any of the namespaces.</p>
</td>
</tr>
</table>
<a name="SEQUENCE_CLASS"></a>
<h2>SEQUENCE CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A class for ordered sequences of items, adding at either end of the sequence. The method names should be familiar to Perl users.</p>
</td>
</tr>
</table>
<a name="SEQUENCE_CONSTRUCTOR"></a>
<h2>SEQUENCE CONSTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_sequence* raptor_new_sequence(raptor_sequence_free_handler*</b> <i>free_handler</i><b>, raptor_sequence_print_handler*</b> <i>print_handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new empty sequence, with optional handler for freeing elements (as used by <b>raptor_free_sequence</b> and printing out elements (used by <b>raptor_sequence_print</b>).</p>
</td>
</tr>
</table>
<a name="SEQUENCE_DESTRUCTOR"></a>
<h2>SEQUENCE DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_sequence(raptor_sequence*</b> <i>seq</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destoy a sequence object, freeing any items if the free handler was defined in the constructor.</p>
</td>
</tr>
</table>
<a name="SEQUENCE_METHODS"></a>
<h2>SEQUENCE METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_sequence_size(raptor_sequence*</b> <i>seq</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the number of items in the sequence.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_sequence_set_at(raptor_sequence*</b> <i>seq</i><b>, int</b> <i>idx</i><b>, void *data)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the sequence item at index <i>idx</i> to the value <i>data</i>, extending it if necessary.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_sequence_push(raptor_sequence*</b> <i>seq</i><b>, void *</b><i>data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Add item <i>data</i> to the end of the sequence.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_sequence_shift(raptor_sequence*</b> <i>seq</i><b>, void *</b><i>data</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Add item <i>data</i> to the start of the sequence.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_sequence_get_at(raptor_sequence*</b> <i>seq</i><b>, int</b> <i>idx</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the sequence item at index <i>idx</i> or NULL if no such index exists.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_sequence_pop(raptor_sequence*</b> <i>seq</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Remove and return an item from the end of the sequence, or NULL if is empty.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_sequence_unshift(raptor_sequence*</b> <i>seq</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Remove and return an item from the start of the sequence, or NULL if is empty.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sequence_sort(raptor_sequence*</b> <i>seq</i><b>, int(*</b><i>compare</i><b>)(const void *, const void *))</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Sort the sequence using the given comparison function <i>compare</i> which is passed to qsort(3) internally.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_compare_strings(const void *</b><i>a</i><b>, const void *</b><i>b</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Helper function useful with <b>raptor_sequence_sort</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sequence_set_print_handler(raptor_sequence *</b><i>seq</i><b>, raptor_sequence_print_handler *</b><i>print_handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the print handler for the sequence, an alternative to setting it in the constructor.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sequence_print_string(char *</b><i>data</i><b>, FILE *</b><i>fh</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Helper print handler function useful for printing out sequences of strings.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sequence_print_uri(char *</b><i>data</i><b>, FILE *</b><i>fh</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Helper print handler function useful for printing out sequences of raptor_uri* objects.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sequence_print(raptor_sequence*</b> <i>seq</i><b>, FILE*</b> <i>fh</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Print out the sequence in a debug format to the given file handler <i>fh</i>. NOTE: The exact format is not guaranteed to remain the same between releases.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_sequence_join(raptor_sequence*</b> <i>dest</i><b>, raptor_sequence *</b><i>src</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Join two sequences moving all items from sequence <i>src</i> to the end of sequence <i>dest</i>. After this operation, sequence <i>src</i> will be empty (zero size) but will have the same item capacity as before.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void* raptor_sequence_delete_at(raptor_sequence*</b> <i>seq</i><b>, int</b> <i>idx</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Remove an item from position <i>idx</i> in the sequence, returning it.</p>
</td>
</tr>
</table>
<a name="STRINGBUFFER_CLASS"></a>
<h2>STRINGBUFFER CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A class for growing strings, small chunks at a time.</p>
</td>
</tr>
</table>
<a name="STRINGBUFFER_CONSTRUCTOR"></a>
<h2>STRINGBUFFER CONSTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_stringbuffer* raptor_new_stringbuffer(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new stringbuffer.</p>
</td>
</tr>
</table>
<a name="STRINGBUFFER_DESTRUCTOR"></a>
<h2>STRINGBUFFER DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_stringbuffer(raptor_stringbuffer*</b> <i>stringbuffer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a stringbuffer.</p>
</td>
</tr>
</table>
<a name="STRINGBUFFER_METHODS"></a>
<h2>STRINGBUFFER METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_append_counted_string(raptor_stringbuffer*</b> <i>stringbuffer</i><b>, const unsigned char *</b><i>string</i><b>, size_t</b> <i>length</i><b>, int</b> <i>do_copy</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Append a <i>string</i> of <i>length</i> bytes to a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_append_string(raptor_stringbuffer*</b> <i>stringbuffer</i><b>, const unsigned char*</b> <i>string</i><b>, int</b> <i>do_copy</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Append a <i>string</i> to a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_append_decimal(raptor_stringbuffer*</b> <i>stringbuffer</i><b>, int</b> <i>integer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Append a formatted decimal <i>integer</i> to a stringbuffer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_append_stringbuffer(raptor_stringbuffer*</b> <i>stringbuffer</i><b>, raptor_stringbuffer*</b> <i>append</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Append a stringbuffer <i>append</i> to a stringbuffer. The append stringbuffer is emptied but not destroyed.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_prepend_counted_string(raptor_stringbuffer*</b> <i>stringbuffer</i><b>, const unsigned char*</b> <i>string</i><b>, size_t</b> <i>length</i><b>, int</b> <i>do_copy</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Prepend a <i>string</i> of <i>length</i> bytes to the start of a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_prepend_string(raptor_stringbuffer*</b> <i>stringbuffer</i><b>, const unsigned char*</b> <i>string</i><b>, int</b> <i>do_copy</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Prepend a <i>string</i> to the start of a stringbuffer, copying it only if <i>do_copy</i> is non-0.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned char * raptor_stringbuffer_as_string(raptor_stringbuffer*</b> <i>stringbuffer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the stringbuffer as a single string. The string is shared and should be copied if needed.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>size_t raptor_stringbuffer_length(raptor_stringbuffer*</b> <i>stringbuffer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the length of the stringbuffer.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_stringbuffer_copy_to_string(raptor_stringbuffer* stringbuffer, unsigned char *</b><i>string</i><b>, size_t</b> <i>len</i><b>gth)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Copy the stringbuffer into a single string buffer <i>string</i> of size <i>length</i>. Returns non-0 on failure.</p>
</td>
</tr>
</table>
<a name="IOSTREAM_CLASS"></a>
<h2>IOSTREAM CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This class provides an I/O stream that can write to filenames, FILE*, strings and user-defined output via callbacks.</p>
</td>
</tr>
</table>
<a name="IOSTREAM_CONSTRUCTOR"></a>
<h2>IOSTREAM CONSTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_from_handler2(void*</b> <i>context</i><b>, const raptor_iostream_handler2 *</b><i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor read or write iostream from a user-defined raptor_iostream_handler2 <i>handler</i> that is called with the passed-in <i>context</i> for the write operations.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_from_handler(void*</b> <i>context</i><b>, const raptor_iostream_handler *</b><i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>DEPRECATED in 1.4.17 - use <b>raptor_new_iostream_from_handler2()</b> with the new handler format. Create a new raptor read iostream from a user-defined raptor_iostream_handler <i>handler</i> that is called with the passed-in <i>context</i> for the write operations.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_to_sink(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor write iostream that discards all written output.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_to_filename(const char *</b><i>filename</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor write iostream that creates and writes to a new file <i>filename</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_to_file_handle(FILE *</b><i>handle</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor write iostream that creates and writes to an existing, already opened, C Standard I/O handle FILE* <i>handle</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_to_string(void **</b><i>string_p</i><b>, size_t *</b><i>length_p</i><b>, void *(*</b><i>malloc_handler</i><b>)(size_t size))</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor write iostream which creates a new string once raptor_free_iostream is called. The new string pointer is written in <i>string</i>, the length in <i>length_p</i> (if not NULL) and the memory allocation is made using the <i>malloc_handler</i>, or if NULL, raptor&#8217;s default memory allocator.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_from_sink(void)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor read iostream that is immediately finished and returns end of file.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_from_filename(const char *</b><i>filename</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor read iostream from an existing file <i>filename</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_from_file_handle(FILE *</b><i>handle</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor read iostream from an already opened, C Standard I/O handle FILE* <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_iostream* raptor_new_iostream_from_string(void *</b><i>string</i><b>, size_t</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new raptor read iostream reading from an existing <i>string</i> of <i>length</i> bytes.</p>
</td>
</tr>
</table>
<a name="IOSTREAM_DESTRUCTOR"></a>
<h2>IOSTREAM DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_iostream(raptor_iostream *</b><i>iostr</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a Raptor iostream object.</p>
</td>
</tr>
</table>
<a name="IOSTREAM_METHODS"></a>
<h2>IOSTREAM METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_bytes(raptor_iostream *</b><i>iostr</i><b>, const void *</b><i>ptr</i><b>, size_t</b> <i>size</i><b>, size_t</b> <i>nmemb</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a counted set of elements to an iostream. Inmemb is the count of elements of size <i>size</i>, starting at memory <i>ptr</i>. Similar to fwrite(3) and write(2).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_byte(raptor_iostream *</b><i>iostr</i><b>, const int</b> <i>byte</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a single <i>byte</i> an iostream. Similar to fputc(3).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_iostream_write_end(raptor_iostream *</b><i>iostr</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Finish writing to an iostream.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_string(raptor_iostream *</b><i>iostr</i><b>, const void *</b><i>string</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a NUL-terminated <i>string</i> to an iostream. Similar to fputs(3).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_counted_string(raptor_iostream *</b><i>iostr</i><b>, const void *</b><i>string</i><b>, size_t</b> <i>len</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a <i>string</i> of length <i>len</i> to an iostream.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>unsigned long raptor_iostream_tell(raptor_iostream *</b><i>iostr</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the byte offset into the iostream.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>size_t raptor_iostream_get_bytes_written_count(raptor_iostream *</b><i>iostr</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>DEPRECATED in 1.4.17 for <b>raptor_iostream_tell()</b>. Return the number of bytes written so far to the iostream.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_decimal(raptor_iostream *</b><i>iostr</i><b>, int</b> <i>integer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a decimal formatted integer <i>integer</i> to the iostream.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_format_hexadecimal(raptor_iostream *</b><i>iostr</i><b>, unsigned int</b> <i>integer</i><b>, int</b> <i>width</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a hexadecimal formatted unsigned <i>integer</i> to the iostream, left-padded with &#8217;0&#8217;s to <i>width</i> columns.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_stringbuffer(raptor_iostream*</b> <i>iostr</i><b>, raptor_stringbuffer *</b><i>sb</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write the stringbuffer to an iostream <i>iostr</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_read_bytes(raptor_iostream*</b> <i>iostr</i><b>, void *</b><i>ptr</i><b>, size_t</b> <i>size</i><b>, size_t</b> <i>nmemb</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Read bytes from the iostream into buffer <i>ptr</i> up to <i>nmemb</i> elements of size <i>size</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_read_eof(raptor_iostream *</b><i>iostr</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-0 if the iostream is finished.</p>
</td>
</tr>
</table>
<a name="XML_SAX2_READER_CLASS"></a>
<h2>XML SAX2 READER CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This class provides the functionality to generate SAX2 events from parsing XML content, including XML namespace support.</p>
</td>
</tr>
</table>
<a name="XML_SAX2_CONSTRUCTOR"></a>
<h2>XML SAX2 CONSTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_sax2* raptor_new_sax2(void *</b><i>user_data</i><b>, raptor_error_handlers*</b> <i>error_handlers</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new SAX2 XML reader with the given error handler object.</p>
</td>
</tr>
</table>
<a name="XML_WRITER_DESTRUCTOR"></a>
<h2>XML WRITER DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_sax2(raptor_sax2 *</b><i>sax2</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a SAX2 XML reader object.</p>
</td>
</tr>
</table>
<a name="SAX2_SET_HANDLER_METHODS"></a>
<h2>SAX2 SET HANDLER METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_start_element_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_start_element_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 start element <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_end_element_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_end_element_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 end element <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_characters_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_characters_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 character data element <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_cdata_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_cdata_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 CDATA section element <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_comment_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_comment_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 XML comment <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_unparsed_entity_decl_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_unparsed_entity_decl_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 XML unparsed entity declaration <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_external_entity_ref_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_sax2_external_entity_ref_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 XML external entity reference <i>handler</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_set_namespace_handler(raptor_sax2 *</b><i>sax2</i><b>, raptor_namespace_handler</b> <i>handler</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the SAX2 XML namespace declaration <i>handler</i> when an XML namespace is declared.</p>
</td>
</tr>
</table>
<a name="SAX2_PARSING_METHODS"></a>
<h2>SAX2 PARSING METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_sax2_parse_start(raptor_sax2 *</b><i>sax2</i><b>, raptor_uri *</b><i>base_uri</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Start a SAX2 parse of XML content with the base URI <i>uri</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_sax2_parse_chunk(raptor_sax2 *</b><i>sax2</i><b>, const unsigned char *</b><i>buffer</i><b>, size_t</b> <i>len</i><b>, int</b> <i>is_end</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Parse the XML content in <i>buffer</i> of size <i>len</i> returning SAX2 events via handlers. If <i>is_end</i> is non-zero, it indicates the end of the parsing. This method can only be called after <b>raptor_sax2_parse_start()</b>.</p>
</td>
</tr>
</table>
<a name="SAX2_SCOPE_METHODS"></a>
<h2>SAX2 SCOPE METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_sax2_inscope_xml_language(raptor_sax2 *</b><i>sax2</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the current in-scope XML language (xml:lang) value.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_uri* raptor_sax2_inscope_base_uri(raptor_sax2 *</b><i>sax2</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the current in-scope Base URI (xml:base or document or protocol) value.</p>
</td>
</tr>
</table>
<a name="XML_ELEMENT_CLASS"></a>
<h2>XML ELEMENT CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This class provides an XML element that can be used with the XML Writer Class to generate XML documents.</p>
</td>
</tr>
</table>
<a name="XML_ELEMENT_CONSTRUCTORS"></a>
<h2>XML ELEMENT CONSTRUCTORS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_xml_element* raptor_new_xml_element(raptor_qname*</b> <i>name</i><b>, const unsigned char*</b> <i>xml_language</i><b>, raptor_uri*</b> <i>xml_base</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new XML element with the element name <i>name</i> in the context of xml:lang <i>xml_language</i> and base URI <i>xml_base</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_xml_element* raptor_new_xml_element_from_namespace_local_name(raptor_namespace *</b><i>ns</i><b>, const unsigned char *</b><i>name</i><b>, const unsigned char*</b> <i>xml_language</i><b>, raptor_uri*</b> <i>xml_base</i></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new XML element based on the given XML <i>namespace</i> and <i>localname</i> in the context of xml:lang <i>xml_language and base URI xml_base.</i></p>
</td>
</tr>
</table>
<a name="XML_ELEMENT_DESTRUCTOR"></a>
<h2>XML ELEMENT DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_xml_element(raptor_xml_element *</b><i>element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a XML element object.</p>
</td>
</tr>
</table>
<a name="XML_ELEMENT_METHODS"></a>
<h2>XML ELEMENT METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname* raptor_xml_element_get_name(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the XML element QName of XML element <i>xml_element</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_element_set_attributes(raptor_xml_element*</b> <i>xml_element</i><b>, raptor_qname **</b><i>attributes</i><b>, int</b> <i>count</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set the attributes on XML element <i>xml_element</i> to the array of QNames in array <i>attributes</i> of size <i>count</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_qname** raptor_xml_element_get_attributes(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the attributes of an XML element <i>xml_element</i> as an array of QNames. As set by <b>void raptor_xml_element_set_attributes</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_element_get_attributes_count(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the number of attributes of an XML element <i>xml_element</i> as set by <b>void raptor_xml_element_set_attributes</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_element_declare_namespace(raptor_xml_element*</b> <i>xml_element</i><b>, raptor_namespace*</b> <i>nspace</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Declare an XML namespace <i>nspace</i> expliclitly on XML element <i>xml_element</i>. Namespaces used in the element or attribute names are automatically declared, this method allows additional ones to be done.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_element_is_empty(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return non-0 if the XML element is empty.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_iostream_write_xml_element(raptor_iostream*</b> <i>iostr</i><b>, raptor_xml_element *</b><i>element</i><b>, raptor_namespace_stack*</b> <i>nstack</i><b>, int</b> <i>is_empty</i><b>, int</b> <i>is_end</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void*</b> <i>error_data</i><b>, int</b> <i>depth</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a XML element <i>xml_element</i> to iostream <i>ostr</i>. This is done in context of an XML namespace stack <i>nstack</i> and at depth <i>depth</i> in the stack (see Namespace class constructors).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The element may be an empty element if <i>is_empty</i> is non-zero or may be a close element if <i>is_end</i> is non-zero (else is a start element). The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char* raptor_xml_element_get_language(raptor_xml_element*</b> <i>xml_element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the xml:lang language of the XML element.</p>
</td>
</tr>
</table>
<a name="XML_WRITER_CLASS"></a>
<h2>XML WRITER CLASS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This class provides the functionality to generate simple XML documents consisting of elements with attributes, character data and comments. The documents can be written to an iostream.</p>
</td>
</tr>
</table>
<a name="XML_WRITER_CONSTRUCTOR"></a>
<h2>XML WRITER CONSTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_xml_writer* raptor_new_xml_writer(raptor_namespace_stack*</b> <i>nstack</i><b>, raptor_uri_handler*</b> <i>uri_handler</i><b>, void*</b> <i>uri_context</i><b>, raptor_iostream*</b> <i>iostr</i><b>, raptor_simple_message_handler</b> <i>error_handler</i><b>, void *</b><i>error_data</i><b>, int</b> <i>canonicalize</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Create a new XML Writer writing to iostream <i>iostr</i>. The <i>error_handler</i> method along with <i>error_data</i> allow error reporting to be given. <i>nstack</i> is either an existing namespace stack to be used or if NULL, a new one with only the XML namespace defined is created. Note that <b>raptor_uri_get_handler</b> can be useful to return the current raptor URI handler/context. <i>canonicalize</i> is currently unused and should be set to 1 but may allow non-canonical XML writing to be allowed in future.</p>
</td>
</tr>
</table>
<a name="XML_WRITER_DESTRUCTOR"></a>
<h2>XML WRITER DESTRUCTOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_free_xml_writer(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Destroy a XML Writer object.</p>
</td>
</tr>
</table>
<a name="XML_WRITER_METHODS"></a>
<h2>XML WRITER METHODS</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_empty_element(raptor_xml_writer*</b> <i>xml_writer</i><b>, raptor_xml_element *</b><i>element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write XML element <i>element</i> as an empty element (no element content) to the XML Writer <i>xml_writer</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_start_element(raptor_xml_writer*</b> <i>xml_writer</i><b>, raptor_xml_element *</b><i>element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a start element along with an attributes and namespace declarations for XML element <i>element</i> to the XML Writer <i>xml_writer</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_end_element(raptor_xml_writer*</b> <i>xml_writer</i><b>, raptor_xml_element *</b><i>element</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write an end element form for XML element <i>element</i> to the XML Writer <i>xml_writer</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_cdata(raptor_xml_writer*</b> <i>xml_writer</i><b>, const unsigned char *str)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write XML character data in <i>str</i> to the XML Writer <i>xml_writer</i>. The characters in <i>str</i> will be XML escaped.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_cdata_counted(raptor_xml_writer*</b> <i>xml_writer</i><b>, const unsigned char*</b> <i>str</i><b>, unsigned int</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write XML character data in <i>str</i> of length <i>length</i> to the XML Writer <i>xml_writer</i>. The characters in <i>str</i> will be XML escaped.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_raw(raptor_xml_writer*</b> <i>xml_writer</i><b>, const unsigned char*</b> <i>str</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write character data in <i>str length</i> to the XML Writer <i>xml_writer</i> without XML escaping.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_raw_counted(raptor_xml_writer*</b> <i>xml_writer</i><b>, const unsigned char*</b> <i>str</i><b>, unsigned int</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write character data in <i>str</i> of length <i>length</i> to the XML Writer <i>xml_writer</i> without XML escaping.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_comment(raptor_xml_writer*</b> <i>xml_writer</i><b>, const unsigned char*</b> <i>str</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write an XML comment in <i>str</i> to the XML Writer <i>xml_writer</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_comment_counted(raptor_xml_writer*</b> <i>xml_writer</i><b>, const unsigned char*</b> <i>str</i><b>, unsigned int</b> <i>length</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write an XML comment in <i>str</i> of length <i>length</i> to the XML Writer <i>xml_writer</i>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_writer_features_enumerate(const raptor_feature</b> <i>feature</i><b>, const char **</b><i>name</i><b>, raptor_uri **</b><i>uri</i><b>, const char **</b><i>label</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Return the name, URI, string label (all optional) for an XML write <i>feature</i>, returning non-zero if no such feature exists.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Raptor features have URIs that are constructed from the URI <i>http://feature.librdf.org/raptor-</i> and the <i>name</i> so for example feature <i>scanForRDF</i> has URI <i>http://feature.librdf.org/raptor-scanForRDF</i></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_writer_set_feature(raptor_xml_writer*</b> <i>xml_writer</i><b>, raptor_feature</b> <i>feature</i><b>, int</b> <i>value</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set an XML writer feature <i>feature</i> to a particular <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined writer features are: <i>Feature Values</i> <b>RAPTOR_FEATURE_WRITER_AUTO_INDENT</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_WRITER_AUTO_EMPTY</b> Boolean (non 0 true) <b>RAPTOR_FEATURE_WRITER_INDENT_WIDTH</b> Integer <b>RAPTOR_FEATURE_WRITER_XML_DECLARATION</b> Boolean (non 0 true)</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If the <i>writer_auto_indent</i> feature is set (default true), the XML writer will automatically indent the output.</p>
<!-- INDENTATION -->
<p>If the <i>writer_auto_empty</i> feature is set (default true), the XML writer will automatically generate empty elements if a start/end element sequence has no content.</p>
<!-- INDENTATION -->
<p>If the <i>writer_indent_width</i> feature is set (default 2) if the XML writer is outputing indented XML, it will use that many spaces.</p>
<!-- INDENTATION -->
<p>If the <i>writer_xml_declaration</i> feature is set (default true) the XML declaration is written at the start of serialized XML.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_writer_set_feature_string(raptor_xml_writer *xml_writer, raptor_feature feature, const unsigned char *value)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Set an XML writer feature <i>feature</i> to a particular string <i>value</i>. Returns non 0 on failure or if the feature is unknown. The current defined XML writer features are given in <b>raptor_xml_writer_set_feature</b> and at present only take integer values. If an integer value feature is set with this function, <i>value</i> is interpreted as an integer and then that value is used.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_writer_get_feature(raptor_xml_writer*</b> <i>xml_writer</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get XML writer feature integer values. The allowed <i>feature</i> values and types are given under <b>raptor_xml_writer_features_enumerate</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const unsigned char *raptor_xml_writer_get_feature_string(raptor_xml_writer*</b> <i>xml_writer</i><b>, raptor_feature</b> <i>feature</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get XML writer feature string values. The allowed <i>feature</i> values and types are given under <b>raptor_xml_writer_features_enumerate</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int raptor_xml_writer_get_depth(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Get the current XML writer element stack depth.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_flush(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Flush the XML writer output for any pending writes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void raptor_xml_writer_newline(raptor_xml_writer*</b> <i>xml_writer</i><b>)</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>Write a newline to the XML writer (which may trigger indenting before the next item).</p>
</td>
</tr>
</table>
<a name="API_CHANGES"></a>
<h2>API CHANGES</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.18</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added atom serializer</p>
<!-- INDENTATION -->
<p>Added rdfa parser</p>
<!-- INDENTATION -->
<p>Added serializer features RAPTOR_FEATURE_RSS_TRIPLES and RAPTOR_FEATURE_ATOM_ENTRY_URI</p>
<!-- INDENTATION -->
<p>Added raptor_qname_to_counted_name</p>
<!-- INDENTATION -->
<p>Added raptor_serialize_start_to_iostream</p>
<!-- INDENTATION -->
<p>Added raptor_sequence_delete_at</p>
<!-- INDENTATION -->
<p>Added raptor_xml_writer_newline</p>
<!-- INDENTATION -->
<p>Added raptor_xml_writer_flush</p>
<!-- INDENTATION -->
<p>Added raptor_xml_writer_get_depth</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.17</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added SAX2 class <b>raptor_sax2</b>. Added new SAX2 API typedefs: <b>raptor_sax2_start_element_handler</b>, <b>raptor_sax2_end_element_handler</b>, <b>raptor_sax2_characters_handler</b>, <b>raptor_sax2_cdata_handler</b>, <b>raptor_sax2_comment_handler</b>, <b>raptor_sax2_unparsed_entity_decl_handler</b> and <b>raptor_sax2_external_entity_ref_handler</b>. Added new SAX2 API functions: <b>raptor_new_sax2()</b>, <b>raptor_free_sax2()</b>, <b>raptor_sax2_set_start_element_handler()</b>, <b>raptor_sax2_set_end_element_handler()</b>, <b>raptor_sax2_set_characters_handler()</b>, <b>raptor_sax2_set_cdata_handler()</b>, <b>raptor_sax2_set_comment_handler()</b>, <b>raptor_sax2_set_unparsed_entity_decl_handler()</b>, <b>raptor_sax2_set_external_entity_ref_handler()</b>, <b>raptor_sax2_set_namespace_handler()</b>, <b>raptor_sax2_parse_start()</b>, <b>raptor_sax2_parse_chunk()</b>, <b>raptor_sax2_inscope_xml_language()</b> and <b>raptor_sax2_inscope_base_uri()</b></p>
<!-- INDENTATION -->
<p>Added features <b>RAPTOR_FEATURE_WRITE_BASE_URI</b>, <b>RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL</b>, <b>RAPTOR_FEATURE_WWW_HTTP_USER_AGENT</b>, <b>RAPTOR_FEATURE_JSON_CALLBACK</b> and <b>RAPTOR_FEATURE_JSON_EXTRA_DATA</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_handler_closure</b> structure for error handlers.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_statement_compare()</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream_write_string_python()</b> and deprecated <b>raptor_iostream_write_string_turtle()</b></p>
<!-- INDENTATION -->
<p><b>raptor_uri_set_handler()</b>, <b>raptor_uri_get_handler()</b>, <b>raptor_new_namespaces()</b>, <b>raptor_namespaces_init()</b> and <b>raptor_new_xml_writer()</b> now take const handler pointers.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_www_set_http_cache_control()</b></p>
<!-- INDENTATION -->
<p>Added QName class methods: <b>raptor_qname_get_local_name()</b>, <b>raptor_qname_get_value()</b> and <b>raptor_qname_get_counted_value()</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream</b> read handler typedefs <b>raptor_iostream_read_bytes_func</b>, <b>raptor_iostream_read_eof_func</b> and added new structure <b>raptor_iostream_handler2</b> replacing deprecated <b>raptor_iostream_handler</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_new_iostream_from_handler2()</b> replacing deprecated <b>raptor_new_iostream_from_handler()</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_new_iostream_from_sink()</b>, <b>raptor_new_iostream_from_filename()</b>, <b>raptor_new_iostream_from_file_handle()</b> and <b>raptor_new_iostream_from_string()</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream_tell</b> deprecating <b>raptor_iostream_get_bytes_written_count()</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream_read_bytes()</b> and <b>raptor_iostream_read_eof()</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_xml_element_get_language()</b>.</p>
<!-- INDENTATION -->
<p>Added new enum <b>raptor_log_level</b>.</p>
<!-- INDENTATION -->
<p>Added new typedef <b>raptor_error_handlers</b>. and new function <b>raptor_error_handlers_init()</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.16</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_namespaces_init</b> now returns an integer status</p>
<!-- INDENTATION -->
<p>Added <b>raptor_new_xml_element_from_namespace_local_name</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_uri_compare</b>.</p>
<!-- INDENTATION -->
<p>Added new features for the &#8217;grddl&#8217; parser: RAPTOR_FEATURE_HTML_TAG_SOUP, RAPTOR_FEATURE_MICROFORMATS and RAPTOR_FEATURE_HTML_LINK.</p>
<!-- INDENTATION -->
<p>Added parser feature RAPTOR_FEATURE_WWW_TIMEOUT</p>
<!-- INDENTATION -->
<p>Added raptor_graph_handler typedef and <b>raptor_set_graph_handler</b></p>
<!-- INDENTATION -->
<p>Added raptor_www_final_uri_handler typedef and <b>raptor_www_set_final_uri_handler</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_www_set_connection_timeout</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_www_get_final_uri</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.15</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.14</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Add two new exported strings raptor_license_string and raptor_home_url_string.</p>
<!-- INDENTATION -->
<p>Added new features for the &#8217;dot&#8217; serializer: RAPTOR_FEATURE_RESOURCE_BORDER, RAPTOR_FEATURE_LITERAL_BORDER, RAPTOR_FEATURE_BNODE_BORDER, RAPTOR_FEATURE_RESOURCE_FILL, RAPTOR_FEATURE_LITERAL_FILL and RAPTOR_FEATURE_BNODE_FILL</p>
<!-- INDENTATION -->
<p>Added <b>raptor_parser_generate_id</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream_write_string_turtle</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.13</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No API changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.12</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No API changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.11</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_get_feature_count</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_get_need_base_uri</b></p>
<!-- INDENTATION -->
<p>Added parser feature <b>RAPTOR_FEATURE_NO_NET</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_www_set_uri_filter</b>, <b>raptor_parser_set_uri_filter</b> with filter type <b>raptor_uri_filter_func</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.10</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No API changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.9</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_parser_get_accept_header</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_xml_element_is_empty</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_qname_get_namespace</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream_write_uri</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_namespaces_qname_from_uri</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_namespace_get_counted_prefix</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_serialize_set_namespace_from_namespace</b></p>
<!-- INDENTATION -->
<p>Deprecated <b>raptor_uri_is_file_uri</b> for new <b>raptor_uri_string_is_file_uri</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_xml_element_get_attributes</b> and <b>raptor_xml_element_get_attributes_count</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.8</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_set_namespace_handler</b>.</p>
<!-- INDENTATION -->
<p>Added XML 1.1 serializing support, feature <b>RAPTOR_FEATURE_WRITER_XML_VERSION</b> with shortname <i>xmlVersion</i> for serializer and xml writer classes to support it. Added XML writer feature <b>RAPTOR_FEATURE_WRITER_XML_DECLARATION</b> to control generation of the XML declaration. Added new functions <b>raptor_xml_any_escape_string</b> and <b>raptor_iostream_write_xml_any_escaped_string</b> to allow generating XML 1.1 or XML 1.0.</p>
<!-- INDENTATION -->
<p><b>RAPTOR_IDENTIFIER_TYPE_PREDICATE</b> will no longer be generated from version 1.4.9 onwards as the type of returned statement predicates. <b>RAPTOR_IDENTIFIER_TYPE_RESOURCE</b> will be returned.</p>
<!-- INDENTATION -->
<p><b>RAPTOR_IDENTIFIER_TYPE_ORDINAL</b> may no longer be generated from version 1.4.9 onwards, <b>RAPTOR_IDENTIFIER_TYPE_RESOURCE</b> may replace it.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.7</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.6</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.5</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Deprecated <b>raptor_ntriples_string_as_utf8_string</b> (never documented above) since it can only work with a raptor_parser object which makes it rather unusable alone.</p>
<!-- INDENTATION -->
<p>Added XML writer features and support functions <b>raptor_xml_writer_features_enumerate</b>, <b>raptor_xml_writer_set_feature</b>, <b>raptor_xml_writer_set_feature_string</b>, <b>raptor_xml_writer_get_feature</b> and <b>raptor_xml_writer_get_feature_string</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.3</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added XML Writer class (<b>raptor_xml_writer</b>) and XML Element class (<b>raptor_xml_element</b>)</p>
<!-- INDENTATION -->
<p>Added <b>raptor_parser_get_feature_string</b>, <b>raptor_parser_set_feature_string</b>, <b>raptor_serializer_set_feature_string</b>, <b>raptor_serializer_get_feature_string</b> and <b>raptor_feature_value_type</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_serializer_set_namespace</b>, <b>raptor_serializer_set_feature</b> and <b>raptor_serializer_get_feature</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_new_namespace_from_uri</b>, <b>raptor_new_namespace_parts_from_string</b>, Added <b>raptor_namespaces_find_namespace_by_uri</b>. and <b>raptor_iostream_write_namespace</b> to write a namespace declaration to an iostream.</p>
<!-- INDENTATION -->
<p>Added copy constructor <b>raptor_qname_copy</b> and <b>raptor_iostream_write_qname</b> to write a qname to an iostream.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_sequence_join</b> to join two sequences, leaving one empty.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_iostream_write_stringbuffer</b> to write a stringbuffer to an iostream.</p>
<!-- INDENTATION -->
<p>Added N-Triples <b>raptor_iostream_write_string_ntriples</b> and <b>raptor_iostream_write_statement_ntriples</b> utility functions for writing to raptor_iostreams.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_uri_to_relative_counted_uri_string</b>, <b>raptor_uri_to_relative_uri_string</b>. <b>raptor_uri_print</b>, <b>raptor_uri_to_counted_string</b> and <b>raptor_uri_to_string</b></p>
<!-- INDENTATION -->
<p>Added unicode name checking utility functions for XML 1.0 and XML 1.1 name starting character and continued name character. <b>raptor_unicode_is_xml10_namestartchar raptor_unicode_is_xml10_namechar</b>, <b>raptor_unicode_is_xml11_namechar</b> and <b>raptor_unicode_is_xml11_namestartchar</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_xml_name_check</b> to check if a name is a legal XML 1.0 or 1.0 name. and <b>raptor_iostream_write_xml_escaped_string</b> to write an XML-escaped string to an iostream.</p>
<!-- INDENTATION -->
<p>Added UTF8-checking utility function <b>raptor_utf8_check</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.2</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>No changes.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.1</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <b>raptor_xml_escape_string</b> now returns &lt;0 on failure rather than 0, so that if an empty string is escaped, 0 bytes required is returned.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.4.0</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added new <b>raptor_serializer</b> class supporting RDF/XML (name <b>rdfxml</b>) and N-Triples (name <b>ntriples</b>).<br />
Added new <b>raptor_iostream</b> class<br />
Added <b>raptor_stringbuffer_copy_to_string</b> to allow efficient copy-out of a constructed string.<br />
Added <b>raptor_www_fetch_to_string</b> to allow retrieving of web content as a single string.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.3.3</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_calloc_memory</b> to provide a calloc inside raptor.<br />
Added feature check_rdf_id (see raptor_set_feature documentation).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.3.2</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_alloc_memory</b> to allocate memory inside raptor.</p>
<!-- INDENTATION -->
<p>Added accessor functions for the public raptor_locator structure:</p>
<!-- INDENTATION -->
<p><b>raptor_locator_line<br />
raptor_locator_column<br />
raptor_locator_byte<br />
raptor_locator_file<br />
raptor_locator_uri</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.3.1</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Correct raptor_print_statement declaration argument statement to have one less &#8217;const&#8217;, to match the code.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.3.0</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added the following parser methods, utility methods and helper functions:</p>
<!-- INDENTATION -->
<p><b>raptor_new_parser_for_content (Parser class constructor)<br />
raptor_get_mime_type<br />
raptor_get_feature<br />
raptor_syntax_name_check<br />
raptor_guess_parser_name<br />
raptor_features_enumerate<br />
raptor_feature_from_uri<br />
raptor_www_set_http_accept (WWW class)</b></p>
<!-- INDENTATION -->
<p>Changed <b>raptor_set_feature</b> to now return an int success or failure.</p>
<!-- INDENTATION -->
<p>Added the following functions:<b><br />
raptor_free_memory<br />
raptor_unicode_char_to_utf8<br />
raptor_utf8_to_unicode_char<br />
raptor_vsnprintf</b></p>
<!-- INDENTATION -->
<p>Added the raptor_sequence class, its constructor, destructor, methods and helper functions.</p>
<!-- INDENTATION -->
<p>Added the raptor_stringbuffer class and constructor, destructor and methods.</p>
<!-- INDENTATION -->
<p>Deprecated <b>raptor_print_statement_detailed</b> always intended to be internal.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.2.0</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_syntaxes_enumerate</b> to get full information on syntax mime type and URIs as well as name and label.</p>
<!-- INDENTATION -->
<p>N-Triples Plus parser renamed to Turtle (name turtle)</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.1.0</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added N-Triples Plus parser (name ntriples-plus)</p>
<!-- INDENTATION -->
<p>Made URI class constructors, methods and factory methods as well as some other utility functions using or returning URIs or literals take unsigned char* rather than char*. The affected calls are:</p>
<!-- INDENTATION -->
<p>URI factory methods changed to all take/return unsigned char* for URI strings:<b><br />
raptor_new_uri_func<br />
raptor_new_uri_from_local_name_func<br />
raptor_new_uri_relative_to_base_func<br />
raptor_uri_as_string_func<br />
raptor_uri_as_counted_string_func</b></p>
<!-- INDENTATION -->
<p>Constructors and methods changed to take/return unsigned char* for URI strings:<b><br />
raptor_statement_part_as_counted_string<br />
raptor_statement_part_as_string<br />
raptor_new_uri<br />
raptor_new_uri_from_uri_local_name<br />
raptor_new_uri_relative_to_base<br />
raptor_uri_as_string<br />
raptor_uri_as_counted_string<br />
raptor_print_ntriples_string</b></p>
<!-- INDENTATION -->
<p>Changed to use unsigned char* for URI strings, char* for filenames:<b><br />
raptor_uri_resolve_uri_reference<br />
raptor_uri_filename_to_uri_string<br />
raptor_uri_uri_string_to_filename<br />
raptor_uri_uri_string_to_filename_fragment<br />
raptor_uri_is_file_uri</b></p>
<!-- INDENTATION -->
<p>Changed to return unsigned char* for UTF8 string:<b><br />
raptor_ntriples_string_as_utf8_string</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_parsers_enumerate</b> to discover supported parsers.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_uri_uri_string_to_filename_fragment</b> with fragment arg to return the URI fragment.</p>
<!-- INDENTATION -->
<p>Made the raptor_namespace, raptor_namespace_stack and raptor_qname class and APIs public.</p>
<!-- INDENTATION -->
<p>Added feature non_nfc_fatal (see raptor_set_feature documentation).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>1.0.0</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Removed the following deprecated methods and functions (see 0.9.6 changes for the new names):<b><br />
raptor_free</b>, <b>raptor_new</b>, <b>raptor_ntriples_free</b>, <b>raptor_ntriples_new</b>, <b>raptor_ntriples_parse_file</b>, <b>raptor_ntriples_set_error_handler</b>, <b>raptor_ntriples_set_fatal_error_handler</b>, <b>raptor_ntriples_set_statement_handler</b> and <b>raptor_parser_abort</b>.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_parse_file_stream</b> for reading FILE* streams without necessarily having a file.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.12</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_new_uri_for_retrieval</b> to turn URI references into URIs suitable for retrieval (no fragments).</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.11</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_get_name</b> and <b>raptor_get_label</b>.</p>
<!-- INDENTATION -->
<p><b>raptor_xml_escape_string</b> now takes error message handler, data pointer, loses parser argument.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_set_default_generate_id_parameters</b> and <b>raptor_set_generate_id_handler</b> to control the default generation of IDs, allow full customisation.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.10</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added <b>raptor_set_parser_strict</b> and <b>raptor_www_no_www_library_init_finish</b>.</p>
<!-- INDENTATION -->
<p><b>raptor_xml_escape_string</b> now takes an output string length pointer.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_statement_part_as_counted_string</b>, <b>raptor_statement_part_as_string and raptor_parse_abort.</b></p>
<!-- INDENTATION -->
<p>Deprecated <b>raptor_parser_abort</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.9</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Added raptor_www class and all its constructors, destructor, methods, calls.</p>
<!-- INDENTATION -->
<p>Added <b>raptor_parse_uri</b>, <b>raptor_parser_abort</b>, <b>raptor_ntriples_term_as_string</b> and <b>raptor_xml_escape_string</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.7</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>raptor_parse_chunk, raptor_new_uri_from_id, arguments are now unsigned char.</b></p>
<!-- INDENTATION -->
<p>Added <b>raptor_new_uri_for_xmlbase</b>.</p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>0.9.6</b></p>
</td>
</tr>
</table>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>In this version, the raptor/ntriples parser calling APIs were modified. The following table lists the changes:</p>
<!-- INDENTATION -->
<p><i>OLD API NEW API (0.9.6+)</i><b><br />
raptor_new() raptor_new_parser("rdfxml")<br />
ntriples_new() raptor_new_parser("ntriples")<br />
raptor_free raptor_free_parser<br />
ntriples_free raptor_ntriples_parser<br />
raptor_ntriples_parse_file raptor_parse_file<br />
raptor_ntriples_set_error_handler raptor_set_error_handler<br />
raptor_ntriples_set_fatal_error_handler raptor_set_fatal_error_handler<br />
raptor_ntriples_set_statement_handler raptor_set_statement_handler</b></p>
</td>
</tr>
</table>
<a name="CONFORMING_TO"></a>
<h2>CONFORMING TO</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><i>RDF/XML Syntax (Revised)</i>, Dave Beckett (ed.) W3C Recommendation, <a href="http://www.w3.org/TR/rdf-syntax-grammar/">http://www.w3.org/TR/rdf-syntax-grammar/</a></p>
<!-- INDENTATION -->
<p><i>N-Triples</i>, in <i>RDF Test Cases</i>, Jan Grant and Dave Beckett (eds.) W3C Recommendation, <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">http://www.w3.org/TR/rdf-testcases/#ntriples</a></p>
<!-- INDENTATION -->
<p><i>Turtle - Terse RDF Triple Language</i>, Dave Beckett, <a href="http://www.dajobe.org/2004/01/turtle/">http://www.dajobe.org/2004/01/turtle/</a></p>
<!-- INDENTATION -->
<p><i>RSS 0.91 spec revision 3</i>, Dan Libby, Netscape, <a href="http://my.netscape.com/publish/formats/rss-spec-0.91.html">http://my.netscape.com/publish/formats/rss-spec-0.91.html</a></p>
<!-- INDENTATION -->
<p><i>RDF Site Summary (RSS) 1.0</i>, <a href="http://purl.org/rss/1.0/spec">http://purl.org/rss/1.0/spec</a></p>
<!-- INDENTATION -->
<p><i>Atom 1.0 syndication format</i>, RFC 4287, <a href="http://www.ietf.org/rfc/rfc4287.txt">http://www.ietf.org/rfc/rfc4287.txt</a></p>
<!-- INDENTATION -->
<p><i>Gleaning Resource Descriptions from Dialects of Languages (GRDDL)</i>, Dan Connolly (ed.), W3C Recommendation, 2007-09-11, <a href="http://www.w3.org/TR/2007/REC-grddl-20070911/">http://www.w3.org/TR/2007/REC-grddl-20070911/</a></p>
</td>
</tr>
</table>
<a name="SEE_ALSO"></a>
<h2>SEE ALSO</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>rapper(1),</b>raptor-config(1)</p>
</td>
</tr>
</table>
<a name="AUTHOR"></a>
<h2>AUTHOR</h2>
<!-- INDENTATION -->
<table width="100%" border="0" rules="none" frame="void" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Dave Beckett - <a href="http://purl.org/net/dajobe/">http://purl.org/net/dajobe/</a></p>
</td>
</tr>
</table>
<hr />

<p>Copyright 2002-2008 <a href="http://purl.org/net/dajobe/">Dave Beckett</a><br />2002-2008 <a href="http://www.bristol.ac.uk/">University of Bristol</a></p>

</body>
</html>
