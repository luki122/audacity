<HTML>
<HEAD>
<TITLE>The RtAudio Tutorial</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Tutorial</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.3.4 -->
<h1>RtAudio.h</h1><div class="fragment"><pre>00001 <span class="comment">/************************************************************************/</span>
00038 <span class="comment">/************************************************************************/</span>
00039 
00040 <span class="comment">// RtAudio: Version 3.0.1, 22 March 2004</span>
00041 
00042 <span class="preprocessor">#ifndef __RTAUDIO_H</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define __RTAUDIO_H</span>
00044 <span class="preprocessor"></span>
00045 <span class="preprocessor">#include "RtError.h"</span>
00046 <span class="preprocessor">#include &lt;string&gt;</span>
00047 <span class="preprocessor">#include &lt;vector&gt;</span>
00048 
00049 <span class="comment">// Operating system dependent thread functionality.</span>
00050 <span class="preprocessor">#if defined(__WINDOWS_DS__) || defined(__WINDOWS_ASIO__)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;windows.h&gt;</span>
00052 <span class="preprocessor">  #include &lt;process.h&gt;</span>
00053 
00054   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ThreadHandle;
00055   <span class="keyword">typedef</span> CRITICAL_SECTION StreamMutex;
00056 
00057 <span class="preprocessor">#else // Various unix flavors with pthread support.</span>
00058 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;pthread.h&gt;</span>
00059 
00060   <span class="keyword">typedef</span> pthread_t ThreadHandle;
00061   <span class="keyword">typedef</span> pthread_mutex_t StreamMutex;
00062 
00063 <span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="comment">// This global structure type is used to pass callback information</span>
00066 <span class="comment">// between the private RtAudio stream structure and global callback</span>
00067 <span class="comment">// handling functions.</span>
00068 <span class="keyword">struct </span>CallbackInfo {
00069   <span class="keywordtype">void</span> *object;    <span class="comment">// Used as a "this" pointer.</span>
00070   ThreadHandle thread;
00071   <span class="keywordtype">bool</span> usingCallback;
00072   <span class="keywordtype">void</span> *callback;
00073   <span class="keywordtype">void</span> *userData;
00074   <span class="keywordtype">void</span> *apiInfo;   <span class="comment">// void pointer for API specific callback information</span>
00075 
00076   <span class="comment">// Default constructor.</span>
00077   CallbackInfo()
00078     :object(0), usingCallback(false), callback(0),
00079      userData(0), apiInfo(0) {}
00080 };
00081 
00082 <span class="comment">// Support for signed integers and floats.  Audio data fed to/from</span>
00083 <span class="comment">// the tickStream() routine is assumed to ALWAYS be in host</span>
00084 <span class="comment">// byte order.  The internal routines will automatically take care of</span>
00085 <span class="comment">// any necessary byte-swapping between the host format and the</span>
00086 <span class="comment">// soundcard.  Thus, endian-ness is not a concern in the following</span>
00087 <span class="comment">// format definitions.</span>
00088 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> RtAudioFormat;
00089 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT8 = 0x1;    
00090 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT16 = 0x2;   
00091 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT24 = 0x4;   
00092 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_SINT32 = 0x8;   
00093 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_FLOAT32 = 0x10; 
00094 <span class="keyword">static</span> <span class="keyword">const</span> RtAudioFormat RTAUDIO_FLOAT64 = 0x20; 
00096 <span class="keyword">typedef</span> int (*RtAudioCallback)(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> bufferSize, <span class="keywordtype">void</span> *userData);
00097 
<a name="l00099"></a><a class="code" href="structRtAudioDeviceInfo.html">00099</a> <span class="keyword">struct </span><a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> {
<a name="l00100"></a><a class="code" href="structRtAudioDeviceInfo.html#o0">00100</a>   std::string <a class="code" href="structRtAudioDeviceInfo.html#o0">name</a>;      
<a name="l00101"></a><a class="code" href="structRtAudioDeviceInfo.html#o1">00101</a>   <span class="keywordtype">bool</span> <a class="code" href="structRtAudioDeviceInfo.html#o1">probed</a>;          
<a name="l00102"></a><a class="code" href="structRtAudioDeviceInfo.html#o2">00102</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o2">outputChannels</a>;   
<a name="l00103"></a><a class="code" href="structRtAudioDeviceInfo.html#o3">00103</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o3">inputChannels</a>;    
<a name="l00104"></a><a class="code" href="structRtAudioDeviceInfo.html#o4">00104</a>   <span class="keywordtype">int</span> <a class="code" href="structRtAudioDeviceInfo.html#o4">duplexChannels</a>;   
<a name="l00105"></a><a class="code" href="structRtAudioDeviceInfo.html#o5">00105</a>   <span class="keywordtype">bool</span> <a class="code" href="structRtAudioDeviceInfo.html#o5">isDefault</a>;       
<a name="l00106"></a><a class="code" href="structRtAudioDeviceInfo.html#o6">00106</a>   std::vector&lt;int&gt; <a class="code" href="structRtAudioDeviceInfo.html#o6">sampleRates</a>; 
<a name="l00107"></a><a class="code" href="structRtAudioDeviceInfo.html#o7">00107</a>   RtAudioFormat <a class="code" href="structRtAudioDeviceInfo.html#o7">nativeFormats</a>;  
00109   <span class="comment">// Default constructor.</span>
00110   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a>()
00111     :<a class="code" href="structRtAudioDeviceInfo.html#o1">probed</a>(false), <a class="code" href="structRtAudioDeviceInfo.html#o2">outputChannels</a>(0), <a class="code" href="structRtAudioDeviceInfo.html#o3">inputChannels</a>(0),
00112        <a class="code" href="structRtAudioDeviceInfo.html#o4">duplexChannels</a>(0), <a class="code" href="structRtAudioDeviceInfo.html#o5">isDefault</a>(false), <a class="code" href="structRtAudioDeviceInfo.html#o7">nativeFormats</a>(0) {}
00113 };
00114 
00115 <span class="comment">// **************************************************************** //</span>
00116 <span class="comment">//</span>
00117 <span class="comment">// RtApi class declaration.</span>
00118 <span class="comment">//</span>
00119 <span class="comment">// Note that RtApi is an abstract base class and cannot be</span>
00120 <span class="comment">// explicitly instantiated.  The class RtAudio will create an</span>
00121 <span class="comment">// instance of an RtApi subclass (RtApiOss, RtApiAlsa,</span>
00122 <span class="comment">// RtApiJack, RtApiCore, RtApiAl, RtApiDs, or RtApiAsio).</span>
00123 <span class="comment">//</span>
00124 <span class="comment">// **************************************************************** //</span>
00125 
00126 <span class="keyword">class </span>RtApi
00127 {
00128 <span class="keyword">public</span>:
00129 
00130   RtApi();
00131   <span class="keyword">virtual</span> ~RtApi();
00132   <span class="keywordtype">void</span> openStream( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00133                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00134                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00135                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00136   <span class="keyword">virtual</span> <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData ) = 0;
00137   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cancelStreamCallback() = 0;
00138   <span class="keywordtype">int</span> getDeviceCount(<span class="keywordtype">void</span>);
00139   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> getDeviceInfo( <span class="keywordtype">int</span> device );
00140   <span class="keywordtype">char</span> * <span class="keyword">const</span> getStreamBuffer();
00141   <span class="keyword">virtual</span> <span class="keywordtype">void</span> tickStream() = 0;
00142   <span class="keyword">virtual</span> <span class="keywordtype">void</span> closeStream();
00143   <span class="keyword">virtual</span> <span class="keywordtype">void</span> startStream() = 0;
00144   <span class="keyword">virtual</span> <span class="keywordtype">void</span> stopStream() = 0;
00145   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abortStream() = 0;
00146 
00147 <span class="keyword">protected</span>:
00148 
00149   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAX_SAMPLE_RATES;
00150   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SAMPLE_RATES[];
00151 
00152   <span class="keyword">enum</span> { FAILURE, SUCCESS };
00153 
00154   <span class="keyword">enum</span> StreamMode {
00155     OUTPUT,
00156     INPUT,
00157     DUPLEX,
00158     UNINITIALIZED = -75
00159   };
00160 
00161   <span class="keyword">enum</span> StreamState {
00162     STREAM_STOPPED,
00163     STREAM_RUNNING
00164   };
00165 
00166   <span class="comment">// A protected structure for audio streams.</span>
00167   <span class="keyword">struct </span>RtApiStream {
00168     <span class="keywordtype">int</span> device[2];          <span class="comment">// Playback and record, respectively.</span>
00169     <span class="keywordtype">void</span> *apiHandle;        <span class="comment">// void pointer for API specific stream handle information</span>
00170     StreamMode mode;         <span class="comment">// OUTPUT, INPUT, or DUPLEX.</span>
00171     StreamState state;       <span class="comment">// STOPPED or RUNNING</span>
00172     <span class="keywordtype">char</span> *userBuffer;
00173     <span class="keywordtype">char</span> *deviceBuffer;
00174     <span class="keywordtype">bool</span> doConvertBuffer[2]; <span class="comment">// Playback and record, respectively.</span>
00175     <span class="keywordtype">bool</span> deInterleave[2];    <span class="comment">// Playback and record, respectively.</span>
00176     <span class="keywordtype">bool</span> doByteSwap[2];      <span class="comment">// Playback and record, respectively.</span>
00177     <span class="keywordtype">int</span> sampleRate;
00178     <span class="keywordtype">int</span> bufferSize;
00179     <span class="keywordtype">int</span> nBuffers;
00180     <span class="keywordtype">int</span> nUserChannels[2];    <span class="comment">// Playback and record, respectively.</span>
00181     <span class="keywordtype">int</span> nDeviceChannels[2];  <span class="comment">// Playback and record channels, respectively.</span>
00182     RtAudioFormat userFormat;
00183     RtAudioFormat deviceFormat[2]; <span class="comment">// Playback and record, respectively.</span>
00184     StreamMutex mutex;
00185     CallbackInfo callbackInfo;
00186 
00187     RtApiStream()
00188       :apiHandle(0), userBuffer(0), deviceBuffer(0) {}
00189     <span class="comment">//      mode(UNINITIALIZED), state(STREAM_STOPPED),</span>
00190   };
00191 
00192   <span class="comment">// A protected device structure for audio devices.</span>
00193   <span class="keyword">struct </span>RtApiDevice {
00194     std::string name;      
00195     <span class="keywordtype">bool</span> probed;           
00196     <span class="keywordtype">void</span> *apiDeviceId;     <span class="comment">// void pointer for API specific device information</span>
00197     <span class="keywordtype">int</span> maxOutputChannels; 
00198     <span class="keywordtype">int</span> maxInputChannels;  
00199     <span class="keywordtype">int</span> maxDuplexChannels; 
00200     <span class="keywordtype">int</span> minOutputChannels; 
00201     <span class="keywordtype">int</span> minInputChannels;  
00202     <span class="keywordtype">int</span> minDuplexChannels; 
00203     <span class="keywordtype">bool</span> hasDuplexSupport; 
00204     <span class="keywordtype">bool</span> isDefault;        
00205     std::vector&lt;int&gt; sampleRates; 
00206     RtAudioFormat nativeFormats;  
00208     <span class="comment">// Default constructor.</span>
00209     RtApiDevice()
00210       :probed(false), apiDeviceId(0), maxOutputChannels(0), maxInputChannels(0),
00211        maxDuplexChannels(0), minOutputChannels(0), minInputChannels(0),
00212        minDuplexChannels(0), isDefault(false), nativeFormats(0) {}
00213   };
00214 
00215   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">short</span> Int16;
00216   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">int</span> Int32;
00217   <span class="keyword">typedef</span> <span class="keywordtype">float</span> Float32;
00218   <span class="keyword">typedef</span> <span class="keywordtype">double</span> Float64;
00219 
00220   <span class="keywordtype">char</span> message_[256];
00221   <span class="keywordtype">int</span> nDevices_;
00222   std::vector&lt;RtApiDevice&gt; devices_;
00223   RtApiStream stream_;
00224 
00229   <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>) = 0;
00230 
00239   <span class="keyword">virtual</span> <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00240 
00249   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00250                                 <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00251                                 <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00252 
00257   <span class="keyword">virtual</span> <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00258 
00263   <span class="keyword">virtual</span> <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00264 
00266   <span class="keywordtype">void</span> clearDeviceInfo( RtApiDevice *info );
00267 
00269   <span class="keywordtype">void</span> clearStreamInfo();
00270 
00272   <span class="keywordtype">void</span> error( RtError::Type type );
00273 
00278   <span class="keywordtype">void</span> verifyStream();
00279 
00284   <span class="keywordtype">void</span> convertStreamBuffer( StreamMode mode );
00285 
00287   <span class="keywordtype">void</span> byteSwapBuffer( <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> samples, RtAudioFormat format );
00288 
00290   <span class="keywordtype">int</span> formatBytes( RtAudioFormat format );
00291 };
00292 
00293 
00294 <span class="comment">// **************************************************************** //</span>
00295 <span class="comment">//</span>
00296 <span class="comment">// RtAudio class declaration.</span>
00297 <span class="comment">//</span>
00298 <span class="comment">// RtAudio is a "controller" used to select an available audio i/o</span>
00299 <span class="comment">// interface.  It presents a common API for the user to call but all</span>
00300 <span class="comment">// functionality is implemented by the class RtAudioApi and its</span>
00301 <span class="comment">// subclasses.  RtAudio creates an instance of an RtAudioApi subclass</span>
00302 <span class="comment">// based on the user's API choice.  If no choice is made, RtAudio</span>
00303 <span class="comment">// attempts to make a "logical" API selection.</span>
00304 <span class="comment">//</span>
00305 <span class="comment">// **************************************************************** //</span>
00306 
<a name="l00307"></a><a class="code" href="classRtAudio.html">00307</a> <span class="keyword">class </span><a class="code" href="classRtAudio.html">RtAudio</a>
00308 {
00309 <span class="keyword">public</span>:
00310 
<a name="l00312"></a><a class="code" href="classRtAudio.html#w8">00312</a>   <span class="keyword">enum</span> <a class="code" href="classRtAudio.html#w8">RtAudioApi</a> {
00313     <a class="code" href="classRtAudio.html#w8w0">UNSPECIFIED</a>,    
00314     <a class="code" href="classRtAudio.html#w8w1">LINUX_ALSA</a>,     
00315     <a class="code" href="classRtAudio.html#w8w2">LINUX_OSS</a>,      
00316     <a class="code" href="classRtAudio.html#w8w3">LINUX_JACK</a>,     
00317     <a class="code" href="classRtAudio.html#w8w4">MACOSX_CORE</a>,    
00318     <a class="code" href="classRtAudio.html#w8w5">IRIX_AL</a>,        
00319     <a class="code" href="classRtAudio.html#w8w6">WINDOWS_ASIO</a>,   
00320     <a class="code" href="classRtAudio.html#w8w7">WINDOWS_DS</a>      
00321   };
00322 
00324 
00334   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( RtAudioApi api=UNSPECIFIED );
00335 
00337 
00348   <a class="code" href="classRtAudio.html#a0">RtAudio</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00349            <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00350            RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00351            <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers, RtAudioApi api=UNSPECIFIED );
00352 
00354 
00358   <a class="code" href="classRtAudio.html#a2">~RtAudio</a>();
00359 
00361 
00387   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a3">openStream</a>( <span class="keywordtype">int</span> outputDevice, <span class="keywordtype">int</span> outputChannels,
00388                    <span class="keywordtype">int</span> inputDevice, <span class="keywordtype">int</span> inputChannels,
00389                    RtAudioFormat format, <span class="keywordtype">int</span> sampleRate,
00390                    <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00391 
00393 
<a name="l00412"></a><a class="code" href="classRtAudio.html#a4">00412</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a4">setStreamCallback</a>(RtAudioCallback callback, <span class="keywordtype">void</span> *userData) { rtapi_-&gt;setStreamCallback( callback, userData ); };
00413 
00415 
<a name="l00422"></a><a class="code" href="classRtAudio.html#a5">00422</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a5">cancelStreamCallback</a>() { rtapi_-&gt;cancelStreamCallback(); };
00423 
<a name="l00425"></a><a class="code" href="classRtAudio.html#a6">00425</a>   <span class="keywordtype">int</span> <a class="code" href="classRtAudio.html#a6">getDeviceCount</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> rtapi_-&gt;getDeviceCount(); };
00426 
00428 
<a name="l00436"></a><a class="code" href="classRtAudio.html#a7">00436</a>   <a class="code" href="structRtAudioDeviceInfo.html">RtAudioDeviceInfo</a> <a class="code" href="classRtAudio.html#a7">getDeviceInfo</a>(<span class="keywordtype">int</span> device) { <span class="keywordflow">return</span> rtapi_-&gt;getDeviceInfo( device ); };
00437 
00439 
<a name="l00444"></a><a class="code" href="classRtAudio.html#a8">00444</a>   <span class="keywordtype">char</span> * <span class="keyword">const</span> <a class="code" href="classRtAudio.html#a8">getStreamBuffer</a>() { <span class="keywordflow">return</span> rtapi_-&gt;getStreamBuffer(); };
00445 
00447 
<a name="l00452"></a><a class="code" href="classRtAudio.html#a9">00452</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a9">tickStream</a>() { rtapi_-&gt;tickStream(); };
00453 
00455 
<a name="l00459"></a><a class="code" href="classRtAudio.html#a10">00459</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a10">closeStream</a>()  { rtapi_-&gt;closeStream(); };
00460 
00462 
<a name="l00466"></a><a class="code" href="classRtAudio.html#a11">00466</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a11">startStream</a>() { rtapi_-&gt;startStream(); };
00467 
00469 
<a name="l00473"></a><a class="code" href="classRtAudio.html#a12">00473</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a12">stopStream</a>() { rtapi_-&gt;stopStream(); };
00474 
00476 
<a name="l00480"></a><a class="code" href="classRtAudio.html#a13">00480</a>   <span class="keywordtype">void</span> <a class="code" href="classRtAudio.html#a13">abortStream</a>() { rtapi_-&gt;abortStream(); };
00481 
00482 
00483  <span class="keyword">protected</span>:
00484 
00485   <span class="keywordtype">void</span> initialize( RtAudioApi api );
00486 
00487   RtApi *rtapi_;
00488 };
00489 
00490 
00491 <span class="comment">// RtApi Subclass prototypes.</span>
00492 
00493 <span class="preprocessor">#if defined(__LINUX_ALSA__)</span>
00494 <span class="preprocessor"></span>
00495 <span class="keyword">class </span>RtApiAlsa: <span class="keyword">public</span> RtApi
00496 {
00497 <span class="keyword">public</span>:
00498 
00499   RtApiAlsa();
00500   ~RtApiAlsa();
00501   <span class="keywordtype">void</span> tickStream();
00502   <span class="keywordtype">void</span> closeStream();
00503   <span class="keywordtype">void</span> startStream();
00504   <span class="keywordtype">void</span> stopStream();
00505   <span class="keywordtype">void</span> abortStream();
00506   <span class="keywordtype">int</span> streamWillBlock();
00507   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00508   <span class="keywordtype">void</span> cancelStreamCallback();
00509 
00510   <span class="keyword">private</span>:
00511 
00512   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00513   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00514   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00515                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00516                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00517 };
00518 
00519 <span class="preprocessor">#endif</span>
00520 <span class="preprocessor"></span>
00521 <span class="preprocessor">#if defined(__LINUX_JACK__)</span>
00522 <span class="preprocessor"></span>
00523 <span class="keyword">class </span>RtApiJack: <span class="keyword">public</span> RtApi
00524 {
00525 <span class="keyword">public</span>:
00526 
00527   RtApiJack();
00528   ~RtApiJack();
00529   <span class="keywordtype">void</span> tickStream();
00530   <span class="keywordtype">void</span> closeStream();
00531   <span class="keywordtype">void</span> startStream();
00532   <span class="keywordtype">void</span> stopStream();
00533   <span class="keywordtype">void</span> abortStream();
00534   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00535   <span class="keywordtype">void</span> cancelStreamCallback();
00536   <span class="comment">// This function is intended for internal use only.  It must be</span>
00537   <span class="comment">// public because it is called by the internal callback handler,</span>
00538   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00539   <span class="comment">// will most likely produce highly undesireable results!</span>
00540   <span class="keywordtype">void</span> callbackEvent( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nframes );
00541 
00542   <span class="keyword">private</span>:
00543 
00544   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00545   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00546   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00547                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00548                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00549 };
00550 
00551 <span class="preprocessor">#endif</span>
00552 <span class="preprocessor"></span>
00553 <span class="preprocessor">#if defined(__LINUX_OSS__)</span>
00554 <span class="preprocessor"></span>
00555 <span class="keyword">class </span>RtApiOss: <span class="keyword">public</span> RtApi
00556 {
00557 <span class="keyword">public</span>:
00558 
00559   RtApiOss();
00560   ~RtApiOss();
00561   <span class="keywordtype">void</span> tickStream();
00562   <span class="keywordtype">void</span> closeStream();
00563   <span class="keywordtype">void</span> startStream();
00564   <span class="keywordtype">void</span> stopStream();
00565   <span class="keywordtype">void</span> abortStream();
00566   <span class="keywordtype">int</span> streamWillBlock();
00567   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00568   <span class="keywordtype">void</span> cancelStreamCallback();
00569 
00570   <span class="keyword">private</span>:
00571 
00572   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00573   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00574   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00575                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00576                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00577 };
00578 
00579 <span class="preprocessor">#endif</span>
00580 <span class="preprocessor"></span>
00581 <span class="preprocessor">#if defined(__MACOSX_CORE__)</span>
00582 <span class="preprocessor"></span>
00583 <span class="preprocessor">#include &lt;CoreAudio/AudioHardware.h&gt;</span>
00584 
00585 <span class="keyword">class </span>RtApiCore: <span class="keyword">public</span> RtApi
00586 {
00587 <span class="keyword">public</span>:
00588 
00589   RtApiCore();
00590   ~RtApiCore();
00591   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00592   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00593   <span class="keywordtype">void</span> tickStream();
00594   <span class="keywordtype">void</span> closeStream();
00595   <span class="keywordtype">void</span> startStream();
00596   <span class="keywordtype">void</span> stopStream();
00597   <span class="keywordtype">void</span> abortStream();
00598   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00599   <span class="keywordtype">void</span> cancelStreamCallback();
00600 
00601   <span class="comment">// This function is intended for internal use only.  It must be</span>
00602   <span class="comment">// public because it is called by the internal callback handler,</span>
00603   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00604   <span class="comment">// will most likely produce highly undesireable results!</span>
00605   <span class="keywordtype">void</span> callbackEvent( AudioDeviceID deviceId, <span class="keywordtype">void</span> *inData, <span class="keywordtype">void</span> *outData );
00606 
00607   <span class="keyword">private</span>:
00608 
00609   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00610   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00611   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00612                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00613                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00614 };
00615 
00616 <span class="preprocessor">#endif</span>
00617 <span class="preprocessor"></span>
00618 <span class="preprocessor">#if defined(__WINDOWS_DS__)</span>
00619 <span class="preprocessor"></span>
00620 <span class="keyword">class </span>RtApiDs: <span class="keyword">public</span> RtApi
00621 {
00622 <span class="keyword">public</span>:
00623 
00624   RtApiDs();
00625   ~RtApiDs();
00626   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00627   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00628   <span class="keywordtype">void</span> tickStream();
00629   <span class="keywordtype">void</span> closeStream();
00630   <span class="keywordtype">void</span> startStream();
00631   <span class="keywordtype">void</span> stopStream();
00632   <span class="keywordtype">void</span> abortStream();
00633   <span class="keywordtype">int</span> streamWillBlock();
00634   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00635   <span class="keywordtype">void</span> cancelStreamCallback();
00636 
00637   <span class="keyword">private</span>:
00638 
00639   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00640   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00641   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00642                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00643                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00644 };
00645 
00646 <span class="preprocessor">#endif</span>
00647 <span class="preprocessor"></span>
00648 <span class="preprocessor">#if defined(__WINDOWS_ASIO__)</span>
00649 <span class="preprocessor"></span>
00650 <span class="keyword">class </span>RtApiAsio: <span class="keyword">public</span> RtApi
00651 {
00652 <span class="keyword">public</span>:
00653 
00654   RtApiAsio();
00655   ~RtApiAsio();
00656   <span class="keywordtype">void</span> tickStream();
00657   <span class="keywordtype">void</span> closeStream();
00658   <span class="keywordtype">void</span> startStream();
00659   <span class="keywordtype">void</span> stopStream();
00660   <span class="keywordtype">void</span> abortStream();
00661   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00662   <span class="keywordtype">void</span> cancelStreamCallback();
00663 
00664   <span class="comment">// This function is intended for internal use only.  It must be</span>
00665   <span class="comment">// public because it is called by the internal callback handler,</span>
00666   <span class="comment">// which is not a member of RtAudio.  External use of this function</span>
00667   <span class="comment">// will most likely produce highly undesireable results!</span>
00668   <span class="keywordtype">void</span> callbackEvent( <span class="keywordtype">long</span> bufferIndex );
00669 
00670   <span class="keyword">private</span>:
00671 
00672   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00673   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00674   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00675                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00676                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00677 };
00678 
00679 <span class="preprocessor">#endif</span>
00680 <span class="preprocessor"></span>
00681 <span class="preprocessor">#if defined(__IRIX_AL__)</span>
00682 <span class="preprocessor"></span>
00683 <span class="keyword">class </span>RtApiAl: <span class="keyword">public</span> RtApi
00684 {
00685 <span class="keyword">public</span>:
00686 
00687   RtApiAl();
00688   ~RtApiAl();
00689   <span class="keywordtype">int</span> getDefaultOutputDevice(<span class="keywordtype">void</span>);
00690   <span class="keywordtype">int</span> getDefaultInputDevice(<span class="keywordtype">void</span>);
00691   <span class="keywordtype">void</span> tickStream();
00692   <span class="keywordtype">void</span> closeStream();
00693   <span class="keywordtype">void</span> startStream();
00694   <span class="keywordtype">void</span> stopStream();
00695   <span class="keywordtype">void</span> abortStream();
00696   <span class="keywordtype">int</span> streamWillBlock();
00697   <span class="keywordtype">void</span> setStreamCallback( RtAudioCallback callback, <span class="keywordtype">void</span> *userData );
00698   <span class="keywordtype">void</span> cancelStreamCallback();
00699 
00700   <span class="keyword">private</span>:
00701 
00702   <span class="keywordtype">void</span> initialize(<span class="keywordtype">void</span>);
00703   <span class="keywordtype">void</span> probeDeviceInfo( RtApiDevice *info );
00704   <span class="keywordtype">bool</span> probeDeviceOpen( <span class="keywordtype">int</span> device, StreamMode mode, <span class="keywordtype">int</span> channels, 
00705                         <span class="keywordtype">int</span> sampleRate, RtAudioFormat format,
00706                         <span class="keywordtype">int</span> *bufferSize, <span class="keywordtype">int</span> numberOfBuffers );
00707 };
00708 
00709 <span class="preprocessor">#endif</span>
00710 <span class="preprocessor"></span>
00711 <span class="comment">// Define the following flag to have extra information spewed to stderr.</span>
00712 <span class="comment">//#define __RTAUDIO_DEBUG__</span>
00713 
00714 <span class="preprocessor">#endif</span>
</pre></div><HR>

<table><tr><td><img src="../images/mcgill.gif" width=165></td>
  <td>&copy;2001-2004 Gary P. Scavone, McGill University. All Rights Reserved.<br>
  Maintained by Gary P. Scavone, <a href="mailto:gary@music.mcgill.ca">gary@music.mcgill.ca</a></td></tr>
</table>

</BODY>
</HTML>
