.TH "Collections of values/objects" 3 "6 Jul 2008" "Version 0.6.0" "SLV2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Collections of values/objects \- Ordered collections of typed values which are fast for random access by index (i.e.  

.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "SLV2PluginClass \fBslv2_plugin_classes_get_by_uri\fP (SLV2PluginClasses classes, SLV2Value uri)"
.br
.ti -1c
.RI "SLV2PluginClass \fBslv2_plugin_classes_get_at\fP (SLV2PluginClasses classes, unsigned index)"
.br
.ti -1c
.RI "void \fBslv2_plugins_free\fP (SLV2World world, SLV2Plugins plugins)"
.br
.ti -1c
.RI "SLV2Plugin \fBslv2_plugins_get_by_uri\fP (SLV2Plugins plugins, SLV2Value uri)"
.br
.ti -1c
.RI "SLV2Plugin \fBslv2_plugins_get_at\fP (SLV2Plugins plugins, unsigned index)"
.br
.ti -1c
.RI "void \fBslv2_uis_free\fP (SLV2UIs list)"
.br
.ti -1c
.RI "SLV2UI \fBslv2_uis_get_by_uri\fP (SLV2UIs list, SLV2Value uri)"
.br
.ti -1c
.RI "SLV2UI \fBslv2_uis_get_at\fP (SLV2UIs list, unsigned index)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_values_get_at\fP (SLV2Values values, unsigned index)"
.br
.ti -1c
.RI "bool \fBslv2_values_contains\fP (SLV2Values values, SLV2Value value)"
.br
.in -1c
.SH "Detailed Description"
.PP 
a fancy array). 
.SH "Function Documentation"
.PP 
.SS "unsigned slv2_plugin_classes_size (SLV2PluginClasses classes)"
.PP
Get the number of plugins in the collection. 
.PP
.SS "SLV2PluginClass slv2_plugin_classes_get_by_uri (SLV2PluginClasses classes, SLV2Value uri)"
.PP
Get a plugin class from the collection by URI. 
.PP
Return value is shared (stored in \fIclasses\fP) and must not be freed or modified by the caller in any way.
.PP
Time = O(log2(n))
.PP
\fBReturns:\fP
.RS 4
NULL if plugin with \fIurl\fP not found in \fIclasses\fP. 
.RE
.PP

.SS "SLV2PluginClass slv2_plugin_classes_get_at (SLV2PluginClasses classes, unsigned index)"
.PP
Get a plugin from the collection by index. 
.PP
\fIindex\fP has no significance other than as an index into \fIclasses\fP. Any \fIindex\fP not less than slv2_plugin_classes_get_length(classes) will return NULL, so all plugin_classes in a classes can be enumerated by repeated calls to this function starting with \fIindex\fP = 0.
.PP
Time = O(1)
.PP
\fBReturns:\fP
.RS 4
NULL if \fIindex\fP out of range. 
.RE
.PP

.SS "void slv2_plugins_free (SLV2World world, SLV2Plugins plugins)"
.PP
Free a plugin plugins. 
.PP
Freeing a plugin collection does not destroy the plugins it contains (plugins are owned by the world). \fIplugins\fP is invalid after this call. 
.SS "unsigned slv2_plugins_size (SLV2Plugins plugins)"
.PP
Get the number of plugins in the collection. 
.PP
.SS "SLV2Plugin slv2_plugins_get_by_uri (SLV2Plugins plugins, SLV2Value uri)"
.PP
Get a plugin from the collection by URI. 
.PP
Return value is shared (stored in \fIplugins\fP) and must not be freed or modified by the caller in any way.
.PP
Time = O(log2(n))
.PP
\fBReturns:\fP
.RS 4
NULL if plugin with \fIurl\fP not found in \fIplugins\fP. 
.RE
.PP

.SS "SLV2Plugin slv2_plugins_get_at (SLV2Plugins plugins, unsigned index)"
.PP
Get a plugin from the plugins by index. 
.PP
\fIindex\fP has no significance other than as an index into this plugins. Any \fIindex\fP not less than slv2_plugins_get_length(plugins) will return NULL, so all plugins in a plugins can be enumerated by repeated calls to this function starting with \fIindex\fP = 0.
.PP
Time = O(1)
.PP
\fBReturns:\fP
.RS 4
NULL if \fIindex\fP out of range. 
.RE
.PP

.SS "void slv2_uis_free (SLV2UIs list)"
.PP
Free a plugin list. 
.PP
Freeing a plugin list does not destroy the plugins it contains (plugins are owned by the world). \fIlist\fP is invalid after this call. 
.SS "unsigned slv2_uis_size (SLV2UIs list)"
.PP
Get the number of plugins in the list. 
.PP
.SS "SLV2UI slv2_uis_get_by_uri (SLV2UIs list, SLV2Value uri)"
.PP
Get a plugin from the list by URI. 
.PP
Return value is shared (stored in \fIlist\fP) and must not be freed or modified by the caller in any way.
.PP
Time = O(log2(n))
.PP
\fBReturns:\fP
.RS 4
NULL if plugin with \fIurl\fP not found in \fIlist\fP. 
.RE
.PP

.SS "SLV2UI slv2_uis_get_at (SLV2UIs list, unsigned index)"
.PP
Get a plugin from the list by index. 
.PP
\fIindex\fP has no significance other than as an index into this list. Any \fIindex\fP not less than slv2_list_get_length(list) will return NULL, so all plugins in a list can be enumerated by repeated calls to this function starting with \fIindex\fP = 0.
.PP
Time = O(1)
.PP
\fBReturns:\fP
.RS 4
NULL if \fIindex\fP out of range. 
.RE
.PP

.SS "SLV2Values slv2_values_new ()"
.PP
Allocate a new, empty SLV2Values. 
.PP
.SS "void slv2_values_free (SLV2Values)"
.PP
Free an SLV2Values. 
.PP
.SS "unsigned slv2_values_size (SLV2Values values)"
.PP
Get the number of elements in a value collection. 
.PP
.SS "SLV2Value slv2_values_get_at (SLV2Values values, unsigned index)"
.PP
Get the value at a given index in the collection. 
.PP
\fBReturns:\fP
.RS 4
the element at \fIindex\fP, or NULL if index is out of range.
.RE
.PP
Time = O(1) 
.SS "bool slv2_values_contains (SLV2Values values, SLV2Value value)"
.PP
Return whether \fIvalues\fP contains \fIvalue\fP. 
.PP
Time = O(n) 
