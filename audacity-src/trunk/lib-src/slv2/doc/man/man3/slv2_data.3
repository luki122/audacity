.TH "Plugin data access" 3 "6 Jul 2008" "Version 0.6.0" "SLV2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Plugin data access \- These functions work exclusively with the plugin's RDF data, they do not access the plugin's shared library in any way.  

.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBslv2_plugin_verify\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_uri\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_bundle_uri\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_data_uris\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_library_uri\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_name\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_value\fP (SLV2Plugin p, SLV2Value predicate)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_value_by_qname\fP (SLV2Plugin p, const char *predicate)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_value_for_subject\fP (SLV2Plugin p, SLV2Value subject_uri, SLV2Value predicate_uri)"
.br
.ti -1c
.RI "bool \fBslv2_plugin_has_feature\fP (SLV2Plugin p, SLV2Value feature_uri)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_supported_features\fP (SLV2Plugin p)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_required_features\fP (SLV2Plugin p)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_get_optional_features\fP (SLV2Plugin p)"
.br
.ti -1c
.RI "uint32_t \fBslv2_plugin_get_num_ports\fP (SLV2Plugin p)"
.br
.ti -1c
.RI "void \fBslv2_plugin_get_port_ranges_float\fP (SLV2Plugin p, float *min_values, float *max_values, float *def_values)"
.br
.ti -1c
.RI "uint32_t \fBslv2_plugin_get_num_ports_of_class\fP (SLV2Plugin p, SLV2Value class_1,...)"
.br
.ti -1c
.RI "bool \fBslv2_plugin_has_latency\fP (SLV2Plugin p)"
.br
.ti -1c
.RI "uint32_t \fBslv2_plugin_get_latency_port_index\fP (SLV2Plugin p)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_plugin_query_variable\fP (SLV2Plugin plugin, const char *sparql_str, unsigned variable)"
.br
.ti -1c
.RI "unsigned \fBslv2_plugin_query_count\fP (SLV2Plugin plugin, const char *sparql_str)"
.br
.ti -1c
.RI "SLV2Port \fBslv2_plugin_get_port_by_index\fP (SLV2Plugin plugin, uint32_t index)"
.br
.ti -1c
.RI "SLV2Port \fBslv2_plugin_get_port_by_symbol\fP (SLV2Plugin plugin, SLV2Value symbol)"
.br
.ti -1c
.RI "SLV2UIs \fBslv2_plugin_get_uis\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_author_name\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_author_email\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_get_author_homepage\fP (SLV2Plugin plugin)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_class_get_parent_uri\fP (SLV2PluginClass plugin_class)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_class_get_uri\fP (SLV2PluginClass plugin_class)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_plugin_class_get_label\fP (SLV2PluginClass plugin_class)"
.br
.ti -1c
.RI "SLV2PluginClasses \fBslv2_plugin_class_get_children\fP (SLV2PluginClass plugin_class)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_ui_get_uri\fP (SLV2UI ui)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_ui_get_classes\fP (SLV2UI ui)"
.br
.ti -1c
.RI "bool \fBslv2_ui_is_a\fP (SLV2UI ui, SLV2Value class_uri)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_ui_get_bundle_uri\fP (SLV2UI ui)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_ui_get_binary_uri\fP (SLV2UI ui)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_port_get_value_by_qname\fP (SLV2Plugin plugin, SLV2Port port, const char *property_uri)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_port_get_properties\fP (SLV2Plugin plugin, SLV2Port port)"
.br
.ti -1c
.RI "bool \fBslv2_port_has_property\fP (SLV2Plugin p, SLV2Port port, SLV2Value property_uri)"
.br
.ti -1c
.RI "bool \fBslv2_port_supports_event\fP (SLV2Plugin p, SLV2Port port, SLV2Value event_uri)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_port_get_symbol\fP (SLV2Plugin plugin, SLV2Port port)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_port_get_name\fP (SLV2Plugin plugin, SLV2Port port)"
.br
.ti -1c
.RI "SLV2Values \fBslv2_port_get_classes\fP (SLV2Plugin plugin, SLV2Port port)"
.br
.ti -1c
.RI "bool \fBslv2_port_is_a\fP (SLV2Plugin plugin, SLV2Port port, SLV2Value port_class)"
.br
.ti -1c
.RI "void \fBslv2_port_get_range\fP (SLV2Plugin plugin, SLV2Port port, SLV2Value *def, SLV2Value *min, SLV2Value *max)"
.br
.ti -1c
.RI "SLV2ScalePoints \fBslv2_port_get_scale_points\fP (SLV2Plugin plugin, SLV2Port port)"
.br
.ti -1c
.RI "SLV2Value \fBslv2_value_new_uri\fP (SLV2World world, const char *uri)"
.br
.ti -1c
.RI "char * \fBslv2_value_get_turtle_token\fP (SLV2Value value)"
.br
.ti -1c
.RI "bool \fBslv2_value_is_uri\fP (SLV2Value value)"
.br
.ti -1c
.RI "const char * \fBslv2_value_as_uri\fP (SLV2Value value)"
.br
.ti -1c
.RI "bool \fBslv2_value_is_literal\fP (SLV2Value value)"
.br
.ti -1c
.RI "bool \fBslv2_value_is_string\fP (SLV2Value value)"
.br
.ti -1c
.RI "const char * \fBslv2_value_as_string\fP (SLV2Value value)"
.br
.ti -1c
.RI "bool \fBslv2_value_is_float\fP (SLV2Value value)"
.br
.ti -1c
.RI "float \fBslv2_value_as_float\fP (SLV2Value value)"
.br
.ti -1c
.RI "bool \fBslv2_value_is_int\fP (SLV2Value value)"
.br
.ti -1c
.RI "int \fBslv2_value_as_int\fP (SLV2Value value)"
.br
.in -1c
.SH "Detailed Description"
.PP 
An SLV2Plugin contains an in-memory cache of the plugin data, loaded on demand. Duplicating plugins should be avoided when possible for performance reasons. 
.SH "Function Documentation"
.PP 
.SS "bool slv2_plugin_verify (SLV2Plugin plugin)"
.PP
Check if this plugin is valid. 
.PP
This is used by plugin lists to avoid loading plugins that are not valid and will not work with libslv2 (eg plugins missing required fields, or having multiple values for mandatory single-valued fields, etc.
.PP
Note that normal hosts do NOT need to use this - slv2 does not load invalid plugins into plugin lists. This is included for plugin testing utilities, etc.
.PP
\fBReturns:\fP
.RS 4
true if \fIplugin\fP is valid.
.RE
.PP
Time = Query 
.SS "SLV2Value slv2_plugin_get_uri (SLV2Plugin plugin)"
.PP
Get the URI of \fIplugin\fP. 
.PP
Any serialization that refers to plugins should refer to them by this. Hosts SHOULD NOT save any filesystem paths, plugin indexes, etc. in saved files; save only the URI.
.PP
The URI is a globally unique identifier for one specific plugin. Two plugins with the same URI are compatible in port signature, and should be guaranteed to work in a compatible and consistent way. If a plugin is upgraded in an incompatible way (eg if it has different ports), it MUST have a different URI than it's predecessor.
.PP
\fBReturns:\fP
.RS 4
a shared string which must not be modified or free()'d.
.RE
.PP
Time = O(1) 
.SS "SLV2Value slv2_plugin_get_bundle_uri (SLV2Plugin plugin)"
.PP
Get the (resolvable) URI of the plugins 'main' bundle. 
.PP
This returns the URI of the bundle where the plugin itself was found. Note that the data for a plugin may be spread over many bundles, that is, slv2_plugin_get_data_uris may returns URIs which are not below this one.
.PP
Typical hosts should not need to use this function.
.PP
Note this always returns a fully qualified URI. If you want a local filesystem path, use slv2_uri_to_path.
.PP
\fBReturns:\fP
.RS 4
a shared string which must not be modified or freed.
.RE
.PP
Time = O(1) 
.SS "SLV2Values slv2_plugin_get_data_uris (SLV2Plugin plugin)"
.PP
Get the (resolvable) URIs of the RDF data files that define a plugin. 
.PP
Typical hosts should not need to use this function.
.PP
Note this always returns fully qualified URIs. If you want local filesystem paths, use slv2_uri_to_path.
.PP
\fBReturns:\fP
.RS 4
a list of complete URLs eg. 'file:///foo/ABundle.lv2/aplug.ttl', which is shared and must not be modified or freed.
.RE
.PP
Time = O(1) 
.SS "SLV2Value slv2_plugin_get_library_uri (SLV2Plugin plugin)"
.PP
Get the (resolvable) URI of the shared library for \fIplugin\fP. 
.PP
Note this always returns a fully qualified URI. If you want a local filesystem path, use slv2_uri_to_path.
.PP
\fBReturns:\fP
.RS 4
a shared string which must not be modified or freed.
.RE
.PP
Time = O(1) 
.SS "SLV2Value slv2_plugin_get_name (SLV2Plugin plugin)"
.PP
Get the name of \fIplugin\fP. 
.PP
This is guaranteed to return the untranslated name (the doap:name in the data file without a language tag). Returned value must be freed by the caller.
.PP
Time = Query 
.SS "SLV2PluginClass slv2_plugin_get_class (SLV2Plugin plugin)"
.PP
Get the class this plugin belongs to (ie Filters). 
.PP
.SS "SLV2Values slv2_plugin_get_value (SLV2Plugin p, SLV2Value predicate)"
.PP
Get a value associated with the plugin in a plugin's data files. 
.PP
Returns the ?object of all triples found of the form:
.PP
\fC<plugin-uri> predicate ?object\fP
.PP
May return NULL if the property was not found, or if object(s) is not sensibly represented as an SLV2Values (e.g. blank nodes).
.PP
Return value must be freed by caller with slv2_values_free.
.PP
\fIpredicate\fP must be either a URI or a QName. See SLV2URIType documentation for examples.
.PP
Time = Query 
.SS "SLV2Values slv2_plugin_get_value_by_qname (SLV2Plugin p, const char * predicate)"
.PP
Get a value associated with the plugin in a plugin's data files. 
.PP
This function is identical to slv2_plugin_get_value, but takes a QName string parameter for a predicate instead of an SLV2Value, which may be more convenient. 
.SS "SLV2Values slv2_plugin_get_value_for_subject (SLV2Plugin p, SLV2Value subject_uri, SLV2Value predicate_uri)"
.PP
Get a value associated with some subject in a plugin's data files. 
.PP
Returns the ?object of all triples found of the form:
.PP
\fCsubject predicate ?object\fP
.PP
This can be used to investigate URIs returned by slv2_plugin_get_value (if information about it is contained in the plugin's data files).
.PP
May return NULL if the property was not found, or if object is not sensibly represented as an SLV2Values (e.g. blank nodes).
.PP
\fIpredicate\fP must be either a URI or a QName. See SLV2URIType documentation for examples.
.PP
Return value must be freed by caller with slv2_values_free.
.PP
Time = Query 
.SS "bool slv2_plugin_has_feature (SLV2Plugin p, SLV2Value feature_uri)"
.PP
Return whether a feature is supported by a plugin. 
.PP
This will return true if the feature is an optional or required feature of the plugin.
.PP
Time = Query 
.SS "SLV2Values slv2_plugin_get_supported_features (SLV2Plugin p)"
.PP
Get the LV2 Features supported (required or optionally) by a plugin. 
.PP
A feature is 'supported' by a plugin if it is required OR optional.
.PP
Since required features have special rules the host must obey, this function probably shouldn't be used by normal hosts. Using slv2_plugin_get_optional_features and slv2_plugin_get_required_features separately is best in most cases.
.PP
Returned value must be freed by caller with slv2_values_free.
.PP
Time = Query 
.SS "SLV2Values slv2_plugin_get_required_features (SLV2Plugin p)"
.PP
Get the LV2 Features required by a plugin. 
.PP
If a feature is required by a plugin, hosts MUST NOT use the plugin if they do not understand (or are unable to support) that feature.
.PP
All values returned here MUST be passed to the plugin's instantiate method (along with data, if necessary, as defined by the feature specification) or plugin instantiation will fail.
.PP
Return value must be freed by caller with slv2_values_free.
.PP
Time = Query 
.SS "SLV2Values slv2_plugin_get_optional_features (SLV2Plugin p)"
.PP
Get the LV2 Features optionally supported by a plugin. 
.PP
Hosts MAY ignore optional plugin features for whatever reasons. Plugins MUST operate (at least somewhat) if they are instantiated without being passed optional features.
.PP
Return value must be freed by caller with slv2_values_free.
.PP
Time = Query 
.SS "uint32_t slv2_plugin_get_num_ports (SLV2Plugin p)"
.PP
Get the number of ports on this plugin. 
.PP
Time = O(1) 
.SS "void slv2_plugin_get_port_ranges_float (SLV2Plugin p, float * min_values, float * max_values, float * def_values)"
.PP
Get the port ranges (minimum, maximum and default values) for all ports. 
.PP
\fImin_values\fP, \fImax_values\fP and \fIdef_values\fP must either point to an array of N floats, where N is the value returned by \fBslv2_plugin_get_num_ports()\fP for this plugin, or NULL. The elements of the array will be set to the the minimum, maximum and default values of the ports on this plugin, with array index corresponding to port index. If a port doesn't have a minimum, maximum or default value, or the port's type is not float, the corresponding array element will be set to NAN.
.PP
This is a convenience method for the common case of getting the range of all float ports on a plugin, and may be significantly faster than repeated calls to slv2_port_get_range. 
.SS "uint32_t slv2_plugin_get_num_ports_of_class (SLV2Plugin p, SLV2Value class_1,  ...)"
.PP
Get the number of ports on this plugin that are members of some class(es). 
.PP
Note that this is a varargs function so ports fitting any type 'profile' desired can be found quickly. REMEMBER TO TERMINATE THE PARAMETER LIST OF THIS FUNCTION WITH NULL OR VERY NASTY THINGS WILL HAPPEN.
.PP
Time = O(1) 
.SS "bool slv2_plugin_has_latency (SLV2Plugin p)"
.PP
Return whether or not the plugin introduces (and reports) latency. 
.PP
The index of the latency port can be found with slv2_plugin_get_latency_port ONLY if this function returns true.
.PP
Time = Query 
.SS "uint32_t slv2_plugin_get_latency_port_index (SLV2Plugin p)"
.PP
Return the index of the plugin's latency port. 
.PP
It is a fatal error to call this on a plugin without checking if the port exists by first calling slv2_plugin_has_latency.
.PP
Any plugin that introduces unwanted latency that should be compensated for (by hosts with the ability/need) MUST provide this port, which is a control rate output port that reports the latency for each cycle in frames.
.PP
Time = Query 
.SS "SLV2Values slv2_plugin_query_variable (SLV2Plugin plugin, const char * sparql_str, unsigned variable)"
.PP
Query a plugin for a single variable (i.e. 
.PP
SELECT a single ?value).
.PP
\fBParameters:\fP
.RS 4
\fIplugin\fP The plugin to query. 
.br
\fIsparql_str\fP A SPARQL SELECT query. 
.br
\fIvariable\fP The index of the variable to return results for (e.g. with '<code>SELECT ?foo ?bar</code>' foo=0, bar=1). 
.RE
.PP
\fBReturns:\fP
.RS 4
All matches for \fIvariable\fP.
.RE
.PP
Time = Query 
.SS "unsigned slv2_plugin_query_count (SLV2Plugin plugin, const char * sparql_str)"
.PP
Query a plugin and return the number of results found. 
.PP
Note that this function will work, but is mostly meaningless for queries that are not SELECT DISTINCT.
.PP
\fBParameters:\fP
.RS 4
\fIplugin\fP The plugin to query. 
.br
\fIsparql_str\fP A SPARQL SELECT DISTINCT query.
.RE
.PP
Time = Query 
.SS "SLV2Port slv2_plugin_get_port_by_index (SLV2Plugin plugin, uint32_t index)"
.PP
Get a port on this plugin by \fIindex\fP. 
.PP
To perform multiple calls on a port, the returned value should be cached and used repeatedly.
.PP
Time = O(1) 
.SS "SLV2Port slv2_plugin_get_port_by_symbol (SLV2Plugin plugin, SLV2Value symbol)"
.PP
Get a port on this plugin by \fIsymbol\fP. 
.PP
To perform multiple calls on a port, the returned value should be cached and used repeatedly. Note this function is slower than slv2_plugin_get_port_by_index, especially on plugins with a very large number of ports.
.PP
Time = O(n) 
.SS "SLV2UIs slv2_plugin_get_uis (SLV2Plugin plugin)"
.PP
Get a list of all UIs available for this plugin. 
.PP
Note this returns the URI of the UI, and not the path/URI to its shared library, use slv2_ui_get_library_uri with the values returned here for that.
.PP
Returned value must be freed by caller using slv2_uis_free.
.PP
\fBParameters:\fP
.RS 4
\fIplugin\fP The plugin to get the UIs for.
.RE
.PP
Time = Query 
.SS "SLV2Value slv2_plugin_get_author_name (SLV2Plugin plugin)"
.PP
Get the full name of the plugin's author. 
.PP
Returns NULL if author name is not present. Returned value must be freed by caller.
.PP
Time = Query 
.SS "SLV2Value slv2_plugin_get_author_email (SLV2Plugin plugin)"
.PP
Get the email address of the plugin's author. 
.PP
Returns NULL if author email address is not present. Returned value must be freed by caller.
.PP
Time = Query 
.SS "SLV2Value slv2_plugin_get_author_homepage (SLV2Plugin plugin)"
.PP
Get the email address of the plugin's author. 
.PP
Returns NULL if author homepage is not present. Returned value must be freed by caller.
.PP
Time = Query 
.SS "SLV2Value slv2_plugin_class_get_parent_uri (SLV2PluginClass plugin_class)"
.PP
Get the URI of this class' superclass. 
.PP
Returned value is owned by \fIplugin_class\fP and must not be freed by caller. Returned value may be NULL, if class has no parent.
.PP
Time = O(1) 
.SS "SLV2Value slv2_plugin_class_get_uri (SLV2PluginClass plugin_class)"
.PP
Get the URI of this plugin class. 
.PP
Returned value is owned by \fIplugin_class\fP and must not be freed by caller.
.PP
Time = O(1) 
.SS "SLV2Value slv2_plugin_class_get_label (SLV2PluginClass plugin_class)"
.PP
Get the label of this plugin class, ie 'Oscillators'. 
.PP
Returned value is owned by \fIplugin_class\fP and must not be freed by caller.
.PP
Time = O(1) 
.SS "SLV2PluginClasses slv2_plugin_class_get_children (SLV2PluginClass plugin_class)"
.PP
Get the subclasses of this plugin class. 
.PP
Returned value must be freed by caller with slv2_plugin_classes_free.
.PP
Time = O(nclasses) 
.SS "SLV2Value slv2_ui_get_uri (SLV2UI ui)"
.PP
Get the URI of a Plugin UI. 
.PP
\fBParameters:\fP
.RS 4
\fIui\fP The Plugin UI
.RE
.PP
Time = O(1) 
.SS "SLV2Values slv2_ui_get_classes (SLV2UI ui)"
.PP
Get the types (URIs of RDF classes) of a Plugin UI. 
.PP
\fBParameters:\fP
.RS 4
\fIui\fP The Plugin UI
.RE
.PP
Time = O(1) 
.SS "bool slv2_ui_is_a (SLV2UI ui, SLV2Value class_uri)"
.PP
Check whether a plugin UI is a given type. 
.PP
\fBParameters:\fP
.RS 4
\fIui\fP The Plugin UI 
.br
\fIclass_uri\fP The URI of the LV2 UI type to check this UI against
.RE
.PP
Time = O(1) 
.SS "SLV2Value slv2_ui_get_bundle_uri (SLV2UI ui)"
.PP
Get the URI for a Plugin UI's bundle. 
.PP
\fBParameters:\fP
.RS 4
\fIui\fP The Plugin UI
.RE
.PP
Time = O(1) 
.SS "SLV2Value slv2_ui_get_binary_uri (SLV2UI ui)"
.PP
Get the URI for a Plugin UI's shared library. 
.PP
\fBParameters:\fP
.RS 4
\fIui\fP The Plugin UI
.RE
.PP
Time = O(1) 
.SS "SLV2Values slv2_port_get_value_by_qname (SLV2Plugin plugin, SLV2Port port, const char * property_uri)"
.PP
Port analog of slv2_plugin_get_value. 
.PP
Time = Query 
.SS "SLV2Values slv2_port_get_properties (SLV2Plugin plugin, SLV2Port port)"
.PP
Return the LV2 port properties of a port. 
.PP
Time = Query 
.SS "bool slv2_port_has_property (SLV2Plugin p, SLV2Port port, SLV2Value property_uri)"
.PP
Return whether a port has a certain property. 
.PP
Time = Query 
.SS "bool slv2_port_supports_event (SLV2Plugin p, SLV2Port port, SLV2Value event_uri)"
.PP
Return whether a port is an event port and supports a certain event type. 
.PP
Time = Query 
.SS "SLV2Value slv2_port_get_symbol (SLV2Plugin plugin, SLV2Port port)"
.PP
Get the symbol of a port. 
.PP
The 'symbol' is a short string, a valid C identifier. Returned value is owned by \fIport\fP and must not be freed.
.PP
Time = Query 
.SS "SLV2Value slv2_port_get_name (SLV2Plugin plugin, SLV2Port port)"
.PP
Get the name of a port. 
.PP
This is guaranteed to return the untranslated name (the doap:name in the data file without a language tag). Returned value must be free()'d by the caller.
.PP
Time = Query 
.SS "SLV2Values slv2_port_get_classes (SLV2Plugin plugin, SLV2Port port)"
.PP
Get all the classes of a port. 
.PP
This can be used to determine if a port is an input, output, audio, control, midi, etc, etc, though it's simpler to use slv2_port_is_a. The returned list does not include lv2:Port, which is implied.
.PP
Returned value is shared and must not be destroyed by caller.
.PP
Time = O(1) 
.SS "bool slv2_port_is_a (SLV2Plugin plugin, SLV2Port port, SLV2Value port_class)"
.PP
Determine if a port is of a given class (input, output, audio, etc). 
.PP
For convenience/performance/extensibility reasons, hosts are expected to create an SLV2Value for each port class they 'care about'. Well-known type URI strings are defined (e.g. SLV2_PORT_CLASS_INPUT) for convenience, but this function is designed so that SLV2 is usable with any port types without requiring explicit support in SLV2.
.PP
Time = O(n) (n pointer comparisons where n is the number of classes of this port, so this method is suitable for realtime use on any sane port). 
.SS "void slv2_port_get_range (SLV2Plugin plugin, SLV2Port port, SLV2Value * def, SLV2Value * min, SLV2Value * max)"
.PP
Get the default, minimum, and maximum values of a port. 
.PP
\fIdef\fP, \fImin\fP, and \fImax\fP are outputs, pass pointers to uninitialized (i.e. NOT created with slv2_value_new) SLV2Value variables. These will be set to point at new values (which must be freed by the caller using slv2_value_free), or NULL if the value does not exist.
.PP
Time = Query 
.SS "SLV2ScalePoints slv2_port_get_scale_points (SLV2Plugin plugin, SLV2Port port)"
.PP
Get the scale points (enumeration values) of a port. 
.PP
This returns a collection of 'interesting' named values of a port (e.g. appropriate entries for a UI selector associated with this port).
.PP
Returned value may be NULL if \fIport\fP has no scale points, otherwise it must be freed by caller with slv2_scale_points_free. 
.SS "SLV2Value slv2_value_new_uri (SLV2World world, const char * uri)"
.PP
Create a new URI value. 
.PP
Returned value must be freed by called with slv2_value_free. 
.SS "void slv2_value_free (SLV2Value val)"
.PP
Free an SLV2Value. 
.PP
.SS "SLV2Value slv2_value_duplicate (SLV2Value val)"
.PP
Duplicate an SLV2Value. 
.PP
.SS "bool slv2_value_equals (SLV2Value value, SLV2Value other)"
.PP
Return whether two values are equivalent. 
.PP
.SS "char* slv2_value_get_turtle_token (SLV2Value value)"
.PP
Return this value as a Turtle/SPARQL token. 
.PP
Examples: <http://example.org/foo> doap:name 'this is a string' 1.0 1
.PP
Returned string is newly allocation and must be freed by caller. 
.SS "bool slv2_value_is_uri (SLV2Value value)"
.PP
Return whether the value is a URI (resource). 
.PP
Time = O(1) 
.SS "const char* slv2_value_as_uri (SLV2Value value)"
.PP
Return this value as a URI string, e.g. 
.PP
'http://example.org/foo'.
.PP
Valid to call only if slv2_value_is_uri(\fIvalue\fP) returns true. Returned value is owned by \fIvalue\fP and must not be freed by caller.
.PP
Time = O(1) 
.SS "bool slv2_value_is_literal (SLV2Value value)"
.PP
Return whether this value is a literal (i.e. 
.PP
not a URI).
.PP
Returns true if \fIvalue\fP is a string or numeric value.
.PP
Time = O(1) 
.SS "bool slv2_value_is_string (SLV2Value value)"
.PP
Return whether this value is a string literal. 
.PP
Returns true if \fIvalue\fP is a string (but not numeric) value.
.PP
Time = O(1) 
.SS "const char* slv2_value_as_string (SLV2Value value)"
.PP
Return whether this value is a string literal. 
.PP
Time = O(1) 
.SS "bool slv2_value_is_float (SLV2Value value)"
.PP
Return whether this value is a decimal literal. 
.PP
Time = O(1) 
.SS "float slv2_value_as_float (SLV2Value value)"
.PP
Return \fIvalue\fP as a float. 
.PP
Valid to call only if slv2_value_is_float(\fIvalue\fP) or slv2_value_is_int(\fIvalue\fP) returns true.
.PP
Time = O(1) 
.SS "bool slv2_value_is_int (SLV2Value value)"
.PP
Return whether this value is an integer literal. 
.PP
Time = O(1) 
.SS "int slv2_value_as_int (SLV2Value value)"
.PP
Return \fIvalue\fP as an integer. 
.PP
Valid to call only if slv2_value_is_int(\fIvalue\fP) returns true.
.PP
Time = O(1) 
